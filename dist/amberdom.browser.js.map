{"version":3,"file":"amberdom.browser.js","sources":["../src/util.js","../src/vnode/index.js","../src/h/index.js","../src/diff/patch-type.js","../src/diff/list-diff.js","../src/diff/index.js","../src/patch/index.js"],"sourcesContent":["export function isArray (obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\nexport function isEmpty(obj) {\n  return Object.keys(obj|| {}).length === 0;\n}\n","import h from '../h/index';\nimport { isArray } from '../util';\nexport default VNode;\n\nconst eventHookRe = /^ev\\-([a-z]+)/;\n\nclass VNode {\n  /**\n   * @param {String} tagName a tag name. Must be specified.\n   * @param {Object} props can be an empty object.\n   * @param {Array} children can be an empty array.\n   */\n  constructor(tagName, props, children) {\n    this.tagName = tagName;\n    this.props = props;\n    this.children = children;\n    this.key = props.key || void 0;\n    this.count = children.reduce((acc, child) => {\n      if (child instanceof VNode)\n        return child.count + acc + 1;\n      else\n        return acc + 1;\n    }, 0);\n    this.cleanups = []; // for cleaning up event listeners.\n\n    delete props.key; // no key will be needed anymore.\n  }\n\n  /**\n   * render a real DOM tree for this VTree rooted at this VNode.\n   */\n  render() {\n    const element = !(/(SVG|svg)/.test(this.tagName))\n      ? document.createElement(this.tagName)\n      : document.createElementNS(\n        \"http://www.w3.org/2000/svg\",\n        \"svg\"\n      );\n\n    const props = this.props;\n    const self = this;\n\n    for (const propName in props) {\n      if (props.hasOwnProperty(propName)) {\n        const _events = propName.match(eventHookRe);\n        if (_events) {\n          // FIXME: might be a better way of handling this.\n          try {\n            const handler = typeof props[propName] === 'function'\n              ? props[propName]\n              : new Function(`(${props[propName]})(...arguments);`);\n            \n            // store it for later detachment, to avoid memory\n            // leaking.\n            this.cleanups.push({\n              evName: _events[1],\n              handler: handler\n            });\n            // avoid bubbling.\n            element.addEventListener(_events[1], handler, false);\n          } catch(e) {\n            console.log(\n              `Warning: listener for event '${_event[1]}' isn't working.\n              If you're specifying this handler in string, please specify a function.`);\n          }\n        }\n        \n        else if (propName === 'className') {\n          element.setAttribute('class', props[propName])\n        }\n\n        else {\n          element.setAttribute(propName, props[propName]);\n        }\n      }\n    }\n\n    this.children.forEach(child => {\n      var childElement;\n\n      if (typeof child === 'string') {\n        \n        childElement = document.createTextNode(child);  \n      }\n      // It is a VNode.\n      else if (child instanceof VNode) {\n        childElement = child.render();\n      }\n      // FIXME: might be buggy.\n      // It is a custom-defined node.\n      else {\n        var _render = child.render || void 0;\n\n        // It is defined as a class.\n        if (typeof _render === 'function') {\n          _render.bind(child);\n          childElement = _render()\n        }\n        // defined as a function.\n        else {\n          childElement = child.render();\n        }\n      }\n      element.appendChild(childElement);\n    });\n\n    this.$el = element;\n    return element;\n  }\n\n  detachEventListeners() {\n    this.cleanups.forEach(event => {\n      this.$el.removeEventListener(event.evName, event.handler);\n    });\n  }\n}","import VNode from '../vnode/index';\nimport { isArray } from '../util';\nexport default h;\n\n\nconst classIdSpliter = /([\\.#]?[^\\s#.]+)/;\nconst spaceStriper = /^\\s*|\\s*$/;\nconst propSpliter = /\\s*=\\s*/;\n\nfunction parseTagName(tagName) {\n  const parts = tagName.split(classIdSpliter);\n  const result = {};\n\n  parts.forEach(part => {\n    if (part === '')  return;\n\n    if (!result.tagName) {\n      result.tagName = part;\n    } else if (part[0] === '.') {\n      (result.className || (result.className = [])).push(part.substr(1));\n    } else if (part[0] === '#') {\n      result.id = part.substr(1);\n    }\n  });\n\n  result.className && result.className.join(' ');\n  return result;\n}\n\n/**\n * \n * @param {String|Function} tagName a built-in tag name or custom function that returns an object created by h.\n * @param {Object} props optional. any style, event listeners, and className should be put here.\n * @param {*} children optional children. Any string, instance of VNode will be children.\n */\nfunction h(tagName, props, ...children) {\n  var tagInfo, vnode;\n\n  (props || (props = {}));\n  (children || (children = []));\n\n  // handle children re-maps.\n  if ((props instanceof VNode) ||\n      (typeof props === 'string')\n    ) {\n    children.unshift(props);\n    props = {};\n  }\n  \n  // handle children re-maps.\n  if (isArray(props)) {\n    children = [...props, children];\n    props = {};\n  }\n\n  // handle object-literal `style`.\n  if (props.style && typeof props.style === 'object') {\n    let style = '';\n\n    for (const key in props.style) {\n      style += `${key}: ${props.style[key]}; `;\n    }\n    props.style = style;\n  }\n\n  // handle array-literal `className`.\n  if (props.className && isArray(props.className)) {\n    props.className = props.className.join(' ');\n  }\n\n  if (typeof tagName === 'string') {\n    tagInfo = parseTagName(tagName);\n    if (tagInfo.className) {\n      (props.className || (props.className = ''));\n      props.className += ' ' + tagInfo.className;\n    }\n    // any children will be handled by VNode, remember there's no\n    // VText.\n    return new VNode(tagInfo.tagName, props, children);\n  } else if (typeof tagName === 'function') {\n    // use `new` in case it is a class.\n    return new tagName(props, children);\n  }\n}","const REPLACE = 'REPLACE';\nconst REORDER = 'REORDER';\nconst PROPS = 'PROPS';\nconst TEXT = 'TEXT';\n\nconst patchType = {\n  REPLACE,\n  REORDER,\n  PROPS,\n  TEXT\n};\n\nexport default patchType;\n","import patchType from './patch-type';\nexport default diff;\n\n\nconst { REPLACE, REORDER, TEXT, PROPS } = patchType;\nfunction diff(oldList, newList, key) {\n  const oldListKeys = getKeys(oldList, key);\n  const newListKeys = getKeys(newList, key);\n  const oldListLength = oldList.length;\n  const newListLength = newList.length;\n  let diffed = oldList.slice();\n  let moves = [];\n\n  // Not a key was provied, don't diff.\n  if (noKeys(oldListKeys) && noKeys(newListKeys)) {\n    let op, start, end, index, inserted;\n\n    if (oldListLength === newListLength) {\n      return {\n        diffed,\n        moves\n      };\n    }\n\n    // Remove accessary nodes.\n    if (oldListLength > newListLength) {\n      op = 'REMOVE';\n      start = newListLength;\n      end = oldListLength;\n      diffed.splice(newListLength, oldListLength - newListLength);\n    }\n    \n    // Insert neccessary nodes.\n    else if (newListLength > oldListLength) {\n      op = 'INSERT';\n      start = oldListLength;\n      end = newListLength;\n      inserted = newList.slice(oldListLength);\n      diffed = [...diffed, ...inserted];\n    }\n\n    for (let i = start; i < end; i++) {\n      moves.push({\n        type: op,\n        index: i,\n        item: newList[i] || null  // It doesn't matter what.\n      });\n    }\n\n    return {\n      diffed,\n      moves\n    };\n\n  }\n  // record the move of the last element.\n  let indexDeltas = new Array(oldListLength).fill(0);\n  let _physicalIndex;\n\n  newListKeys.forEach((key, newIndex) => {\n    let _physicalIndex = oldListKeys.indexOf(key);\n\n    if (_physicalIndex === -1) {\n      // Element doesn't exist in `newList` yet. Tell it to\n      // insert it.\n      moves.push({\n        type: 'INSERT',\n        index: newIndex,\n        item: newList[newIndex]\n      });\n      diffed.splice(newIndex, 0, newList[newIndex]);\n\n      // positions of all unprocessed elements should take this delta.\n      indexDeltas[oldListLength - 1]++;\n    } else {\n      let oldIndex = _physicalIndex;\n\n      for (let i = oldListLength - 1; i >= _physicalIndex; i--) {\n        oldIndex += indexDeltas[i];\n      }\n\n      // If it is already in place, don't do anything.\n      if (newIndex === oldIndex)  return;\n\n      moves.push({\n        type: 'MOVE',\n        from: oldIndex, \n        to: newIndex\n      });\n      let _elem = diffed.splice(oldIndex, 1)[0];\n      diffed.splice(newIndex, 0, _elem)\n\n      // It is impossible to move element from front to back.\n      indexDeltas[_physicalIndex]++;\n    }\n  });\n\n  // remove extra.\n  oldListKeys.forEach((key, i) => {\n    \n    if (newListKeys.indexOf(key) === -1) {\n      moves.push({\n        type: 'REMOVE',\n        index: newListLength  // all extra items must've been moved to end.\n      });\n      diffed.splice(newListLength, 1);\n    }\n  });\n\n  return {\n    diffed,\n    moves\n  };\n}\n\n// Elements with no `key` field is to be removed.\nfunction getKeys(list, key) {\n  return list.map((item, i) => {\n    if (key && item) {\n      return typeof key === 'function'\n        ? key(item)\n        : item[key];\n    } else  return void 0;\n  });\n}\n\n\nfunction noKeys(list) {\n  for (const item of list)\n    if (item !== void 0)\n      return false;\n\n  return true;\n}","import listDiff from './list-diff';\nimport { isEmpty } from '../util';\nimport patchType from './patch-type';\n\n\nconst { REPLACE, REORDER, TEXT, PROPS } = patchType;\n\nexport default function diff (oldTree, newTree) {\n  const patches = {};\n  walk(oldTree, newTree, patches, 0);\n  return patches;\n}\n\nfunction walk(oldNode, newNode, patches, index) {\n  var currPatches = [];\n  var propPatches, childrenPatches;\n\n  // TODO: let custom-defined component take control of diffing.\n\n  if (newNode === void 0) {\n    // oldNode will be removed.\n    return patches;\n  }\n\n  // both Text node.\n  else if (typeof oldNode === 'string' && typeof newNode === 'string') {\n\n    if (oldNode === newNode) {\n      // nothing to patch.\n    } else {\n      patches[index] = [{ type: TEXT, text: newNode }];\n    }\n    // there would be no props nor children.\n    return patches;\n  }\n\n  propPatches = diffProps(oldNode.props || {}, newNode.props || {});\n\n  // the whole node should be replaced, if tag names are not the same\n  // or keys diffed.splice(oldListLength, 0, ...inserted); are not the same.\n  if (oldNode.tagName !== newNode.tagName ||\n      oldNode.key !== newNode.key) {\n    \n      currPatches.push({\n        type: REPLACE,\n        node: newNode\n      });\n      patches[index] = currPatches;\n      // do not diff their children anymore.\n      return patches;\n  }\n  // only patch some props.\n  else if (!isEmpty(propPatches)) {\n    currPatches.push({\n      type: PROPS,\n      props: propPatches\n    });\n  }\n\n  diffChildren(\n    oldNode.children || [],\n    newNode.children || [],\n    patches,\n    currPatches,\n    index\n  );\n  if (currPatches.length) {\n    patches[index] = currPatches;\n  }\n  return patches;\n}\n\nfunction diffProps(oldProps, newProps) {\n  var propPatches = {}, value;\n\n  // update props.\n  for (const propName in newProps) {\n    if (newProps.hasOwnProperty(propName)) {\n      value = newProps[propName];\n      if (oldProps[propName] !== value) {\n        propPatches[propName] = value;\n      }\n    }\n  }\n  // remove old props.\n  for (const propName in oldProps) {\n    if (!(propName in newProps))\n      propPatches[propName] = void 0;\n  }\n  return propPatches;\n}\n\n\nfunction diffChildren(oldChildren, \n  newChildren, patches, currPatches, index) {\n  const diffs = listDiff(oldChildren, newChildren, 'key');\n\n  oldChildren = diffs.diffed; // Must reorder them first before steppin deeper.\n  if (diffs.moves.length) {\n    currPatches.push({\n      type: REORDER,\n      moves: diffs.moves\n    });\n  }\n\n  var prevSibling = null;\n  var currIndex = index;\n  oldChildren.forEach((child, i) => {\n    const newChild = newChildren[i];\n    currIndex = (prevSibling && prevSibling.count)\n      ? prevSibling.count + currIndex + 1\n      : currIndex + 1;  // the first child.\n    walk(child, newChildren[i], patches, currIndex);\n    prevSibling = child;\n  });\n}","import VNode from '../vnode/index';\nimport patchType from '../diff/patch-type.js';\nexport default patch;\n\n\nconst { REPLACE, REORDER, PROPS, TEXT } = patchType;\n\nfunction patch(domRoot, patches) {\n  walk(domRoot, patches, { index: 0 });\n}\n\n// walker keeps the complexity away.\n// `walk` updates the domTree buttom-up.\nfunction walk(domNode, patches, walker) {\n  const currPatches = patches[walker.index];\n\n  // changes should be applied for this node first\n  // in case one of childNodes of `domNode` is removed.\n  // Thus if patches are applied to childNodes first,\n  // and if that patched child node is later on removed,\n  // no effect will be taken into account.\n  if(currPatches) {\n    applyPatches(domNode, currPatches);\n  }\n\n  if (domNode.childNodes) {\n    const childArr = [].slice.call(domNode.childNodes);\n    childArr.forEach((child, i) => {\n      walker.index++;\n      walk(child, patches, walker);\n    });\n  }\n}\n\n/**\n * patch a single dom node.\n * @param {NodeList} domNode \n * @param {Array} patch \n */\nfunction applyPatches(domNode, patches) {\n  let props, newNode;\n\n  patches.forEach(patch => {\n    switch(patch.type) {\n    case REPLACE:\n      newNode = (patch.node instanceof VNode || patch.node.render)\n        ? patch.node.render() // an instance of VNode or a custom node.\n        : typeof patch.node === 'string'\n        ? document.createTextNode(patch.node)\n        : new Error('You might be using a custom node, if so, you need to provide a render function.');\n      if (newNode instanceof Error) {\n        throw newNode;\n      }\n      domNode.parentNode.replaceChild(newNode, domNode);\n      break;\n\n    case PROPS:\n      props = patch.props;\n      for (let propName in props) {\n        if (props[propName] === void 0)\n          domNode.removeAttribute(propName !== 'className' ? propName : 'class');\n        else\n          domNode.setAttribute(propName !== 'className' ? propName : 'class', props[propName]);\n      }\n      break;\n\n    case TEXT:\n      if (domNode.textContent) {\n        domNode.textContent = patch.text;\n      } else {\n        domNode.nodeValue = patch.text;\n      }\n      break;\n    \n    case REORDER:\n      reorderChildren(domNode, patch.moves);\n      break;\n\n    default:\n      throw new Error('Some internal error.');\n    }\n  });\n}\n\n// TODO: Add batch.\nfunction reorderChildren(domNode, moves) {\n  const childNodes = domNode.childNodes;\n  let node;\n\n  moves.forEach(move => {\n  switch(move.type) {\n    case 'INSERT':\n      try {\n        node = move.item.render();\n        domNode.insertBefore(node, childNodes[move.index]);\n      } catch (e) {\n        console.log('A custom-defined node should have a render method, otherwise it must be defined as a function.');\n      }\n      break;\n\n    case 'REMOVE':\n      domNode.removeChild(childNodes[move.index]);\n      break;\n\n    case 'MOVE':\n      domNode.insertBefore(childNodes[move.from], childNodes[move.to]);\n      break;\n    }\n  });\n}"],"names":["isArray","obj","Object","prototype","toString","call","eventHookRe","VNode","tagName","props","children","key","count","reduce","acc","child","cleanups","element","test","this","document","createElementNS","createElement","propName","hasOwnProperty","_events","match","handler","Function","push","addEventListener","e","log","_event","setAttribute","forEach","childElement","createTextNode","render","_render","bind","appendChild","$el","removeEventListener","event","evName","classIdSpliter","patchType","getKeys","list","map","item","i","noKeys","REPLACE","REORDER","TEXT","PROPS","walk","oldNode","newNode","patches","index","propPatches","currPatches","type","text","oldProps","newProps","value","diffProps","keys","length","oldChildren","newChildren","diffs","oldList","newList","oldListKeys","newListKeys","oldListLength","newListLength","diffed","slice","moves","op","start","end","splice","inserted","indexDeltas","Array","fill","newIndex","_physicalIndex","indexOf","oldIndex","_elem","listDiff","prevSibling","currIndex","tagInfo","unshift","style","_typeof","className","join","result","split","part","substr","id","parseTagName","oldTree","newTree","domRoot","domNode","walker","patch","node","Error","parentNode","replaceChild","removeAttribute","textContent","nodeValue","childNodes","move","insertBefore","removeChild","from","to","childArr"],"mappings":"oLAAO,SAASA,EAASC,SACwB,mBAAxCC,OAAOC,UAAUC,SAASC,KAAKJ,4PCGxC,IAAMK,EAAc,gBAEdC,wBAMQC,EAASC,EAAOC,8GACrBF,QAAUA,OACVC,MAAQA,OACRC,SAAWA,OACXC,IAAMF,EAAME,UAAO,OACnBC,MAAQF,EAASG,OAAO,SAACC,EAAKC,UAC7BA,aAAiBR,EACZQ,EAAMH,MAAQE,EAAM,EAEpBA,EAAM,GACd,QACEE,mBAEEP,EAAME,mDAOPM,EAAY,YAAYC,KAAKC,KAAKX,SAEpCY,SAASC,gBACT,6BACA,OAHAD,SAASE,cAAcH,KAAKX,SAM1BC,EAAQU,KAAKV,UAGd,IAAMc,KAAYd,KACjBA,EAAMe,eAAeD,GAAW,KAC5BE,EAAUF,EAASG,MAAMpB,MAC3BmB,UAGME,EAAqC,mBAApBlB,EAAMc,GACzBd,EAAMc,GACN,IAAIK,aAAanB,EAAMc,4BAItBP,SAASa,aACJJ,EAAQ,WACPE,MAGHG,iBAAiBL,EAAQ,GAAIE,GAAS,GAC9C,MAAMI,WACEC,oCAC0BC,OAAO,kHAKvB,cAAbV,IACCW,aAAa,QAASzB,EAAMc,MAI5BW,aAAaX,EAAUd,EAAMc,gBAKtCb,SAASyB,QAAQ,gBAChBC,KAEiB,iBAAVrB,IAEMK,SAASiB,eAAetB,QAGpC,GAAIA,aAAiBR,IACTQ,EAAMuB,aAIlB,KACCC,EAAUxB,EAAMuB,aAAU,EAGP,mBAAZC,KACDC,KAAKzB,KACEwB,OAIAxB,EAAMuB,WAGjBG,YAAYL,UAGjBM,IAAMzB,EACJA,iEAIFD,SAASmB,QAAQ,cACfO,IAAIC,oBAAoBC,EAAMC,OAAQD,EAAMjB,gOC3GvD,IAAMmB,EAAiB,mBCLvB,IAKMC,EALU,UAKVA,EAJU,UAIVA,EAHQ,QAGRA,EAFO,+HCiHb,SAASC,EAAQC,EAAMtC,UACdsC,EAAKC,IAAI,SAACC,EAAMC,UACjBzC,GAAOwC,EACa,mBAARxC,EACVA,EAAIwC,GACJA,EAAKxC,QACH,IAKZ,SAAS0C,EAAOJ,0CACKA,0DACJ,YACX,OAAO,uFAEJ,MC/HDK,EAAkCP,EAAzBQ,EAAyBR,EAAhBS,EAAgBT,EAAVU,EAAUV,EAQ1C,SAASW,EAAKC,EAASC,EAASC,EAASC,OAEnCC,ELXkB9D,EKUlB+D,iBAKY,IAAZJ,EAEKC,EAImB,iBAAZF,GAA2C,iBAAZC,GAEzCD,IAAYC,MAGNE,KAAYG,KAAMT,EAAMU,KAAMN,KAGjCC,MAuCX,SAAmBM,EAAUC,OACLC,EAAlBN,SAGC,IAAMxC,KAAY6C,EACjBA,EAAS5C,eAAeD,OAClB6C,EAAS7C,GACb4C,EAAS5C,KAAc8C,MACb9C,GAAY8C,QAKzB,IAAM9C,KAAY4C,EACf5C,KAAY6C,IAChBL,EAAYxC,QAAY,UAErBwC,EArDOO,CAAUX,EAAQlD,UAAamD,EAAQnD,WAIjDkD,EAAQnD,UAAYoD,EAAQpD,SAC5BmD,EAAQhD,MAAQiD,EAAQjD,OAEZkB,WACJyB,OACAM,MAEAE,GAASE,EAEVH,IL7CW5D,EKgDJ8D,EL/CsB,IAAjC7D,OAAOqE,KAAKtE,OAAUuE,UKgDf3C,WACJ4B,QACCM,IAsCb,SAAsBU,EACpBC,EAAab,EAASG,EAAaF,OAC7Ba,ED1FR,SAAcC,EAASC,EAASlE,OACxBmE,EAAc9B,EAAQ4B,EAASjE,GAC/BoE,EAAc/B,EAAQ6B,EAASlE,GAC/BqE,EAAgBJ,EAAQJ,OACxBS,EAAgBJ,EAAQL,OAC1BU,EAASN,EAAQO,QACjBC,QAGA/B,EAAOyB,IAAgBzB,EAAO0B,GAAc,KAC1CM,SAAIC,SAAOC,SAAKzB,YAEhBkB,IAAkBC,2BAQlBD,EAAgBC,KACb,WACGA,IACFD,IACCQ,OAAOP,EAAeD,EAAgBC,IAItCA,EAAgBD,MAClB,WACGA,IACFC,IACKJ,EAAQM,MAAMH,iBACZE,KAAWO,SAGrB,IAAIrC,EAAIkC,EAAOlC,EAAImC,EAAKnC,MACrBvB,WACEwD,QACCjC,OACDyB,EAAQzB,IAAM,oCAWtBsC,EAAc,IAAIC,MAAMX,GAAeY,KAAK,YAGpCzD,QAAQ,SAACxB,EAAKkF,OACpBC,EAAiBhB,EAAYiB,QAAQpF,OAEjB,IAApBmF,IAGIjE,WACE,eACCgE,OACDhB,EAAQgB,OAETL,OAAOK,EAAU,EAAGhB,EAAQgB,MAGvBb,EAAgB,SACvB,SACDgB,EAAWF,EAEN1C,EAAI4B,EAAgB,EAAG5B,GAAK0C,EAAgB1C,OACvCsC,EAAYtC,MAItByC,IAAaG,EAAW,SAEtBnE,WACE,YACAmE,KACFH,QAEFI,EAAQf,EAAOM,OAAOQ,EAAU,GAAG,KAChCR,OAAOK,EAAU,EAAGI,KAGfH,UAKJ3D,QAAQ,SAACxB,EAAKyC,IAEU,IAA9B2B,EAAYgB,QAAQpF,OAChBkB,WACE,eACCoD,MAEFO,OAAOP,EAAe,yBCVnBiB,CAASzB,EAAaC,EAAa,SAEnCC,EAAMO,OAChBP,EAAMS,MAAMZ,UACF3C,WACJ0B,QACCoB,EAAMS,YAIbe,EAAc,KACdC,EAAYtC,IACJ3B,QAAQ,SAACpB,EAAOqC,GACTsB,EAAYtB,KAChB+C,GAAeA,EAAYvF,MACpCuF,EAAYvF,MAAQwF,EAAY,EAChCA,EAAY,IACXrF,EAAO2D,EAAYtB,GAAIS,EAASuC,KACvBrF,KArDd4C,EAAQjD,aACRkD,EAAQlD,aACRmD,EACAG,EACAF,GAEEE,EAAYQ,WACNV,GAASE,GAEZH,QChEDP,EAAkCP,EAAzBQ,EAAyBR,EAAhBU,EAAgBV,EAATS,EAAST,WJ8B1C,SAAWvC,EAASC,8BAAUC,uDACxB2F,SAEO5F,UACGC,OAGTD,aAAiBF,GACA,iBAAVE,OAED6F,QAAQ7F,SAKfT,EAAQS,wIACKA,IAAOC,UAKpBD,EAAM8F,OAAgC,WAAvBC,EAAO/F,EAAM8F,OAAoB,KAC9CA,EAAQ,OAEP,IAAM5F,KAAOF,EAAM8F,SACV5F,OAAQF,EAAM8F,MAAM5F,UAE5B4F,MAAQA,SAIZ9F,EAAMgG,WAAazG,EAAQS,EAAMgG,eAC7BA,UAAYhG,EAAMgG,UAAUC,KAAK,MAGlB,iBAAZlG,MA7Db,SAAsBA,OAEdmG,YADQnG,EAAQoG,MAAM9D,GAGtBX,QAAQ,YACC,KAAT0E,IAECF,EAAOnG,QAEW,MAAZqG,EAAK,IACbF,EAAOF,YAAcE,EAAOF,eAAiB5E,KAAKgF,EAAKC,OAAO,IAC1C,MAAZD,EAAK,OACPE,GAAKF,EAAKC,OAAO,MAJjBtG,QAAUqG,OAQdJ,WAAaE,EAAOF,UAAUC,KAAK,KACnCC,EA6CKK,CAAaxG,IACXiG,cACHA,YAAchG,EAAMgG,UAAY,MACjCA,WAAa,IAAMJ,EAAQI,WAI5B,IAAIlG,EAAM8F,EAAQ7F,QAASC,EAAOC,IACb,mBAAZF,EAET,IAAIA,EAAQC,EAAOC,QAFrB,QGxEM,SAAeuG,EAASC,OAC/BrD,cACDoD,EAASC,EAASrD,EAAS,GACzBA,SCHT,SAAesD,EAAStD,IAMxB,SAASH,EAAK0D,EAASvD,EAASwD,OACxBrD,EAAcH,EAAQwD,EAAOvD,UAOhCE,GAkBL,SAAsBoD,EAASvD,OACzBpD,SAAOmD,WAEHzB,QAAQ,mBACPmF,EAAMrD,WACRX,QACQgE,EAAMC,gBAAgBhH,GAAS+G,EAAMC,KAAKjF,OACjDgF,EAAMC,KAAKjF,SACW,iBAAfgF,EAAMC,KACbnG,SAASiB,eAAeiF,EAAMC,MAC9B,IAAIC,MAAM,8FACSA,YACf5D,IAEA6D,WAAWC,aAAa9D,EAASwD,cAGtC3D,MAEE,IAAIlC,OADD+F,EAAM7G,WAEY,IAApBA,EAAMc,GACR6F,EAAQO,gBAA6B,cAAbpG,EAA2BA,EAAW,SAE9D6F,EAAQlF,aAA0B,cAAbX,EAA2BA,EAAW,QAASd,EAAMc,eAI3EiC,EACC4D,EAAQQ,cACFA,YAAcN,EAAMpD,OAEpB2D,UAAYP,EAAMpD,gBAIzBX,GAWT,SAAyB6D,EAAShC,OAC1B0C,EAAaV,EAAQU,WACvBP,WAEEpF,QAAQ,mBACP4F,EAAK9D,UACL,eAEM8D,EAAK5E,KAAKb,WACT0F,aAAaT,EAAMO,EAAWC,EAAKjE,QAC3C,MAAO/B,WACCC,IAAI,4GAIX,WACKiG,YAAYH,EAAWC,EAAKjE,kBAGjC,SACKkE,aAAaF,EAAWC,EAAKG,MAAOJ,EAAWC,EAAKI,SA9B5Cf,EAASE,EAAMlC,2BAIzB,IAAIoC,MAAM,4BAzDLJ,EAASpD,GAGpBoD,EAAQU,WAAY,KAChBM,KAAcjD,MAAM9E,KAAK+G,EAAQU,cAC9B3F,QAAQ,SAACpB,EAAOqC,KAChBU,UACF/C,EAAO8C,EAASwD,OArBpBF,EAAStD,GAAWC,MAAO"}