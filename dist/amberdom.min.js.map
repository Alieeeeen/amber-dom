{"version":3,"file":"amberdom.min.js","sources":["../src/util.js","../src/vnode/index.js","../src/h/index.js","../src/diff/patch-type.js","../src/diff/list-diff.js","../src/diff/index.js","../src/patch/index.js"],"sourcesContent":["export function isArray (obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\nexport function isEmpty(obj) {\n  return Object.keys(obj|| {}).length === 0;\n}\n\nexport const eventHookRe = /^ev\\-([a-z]+)/;","import h from '../h/index';\nimport { isArray, eventHookRe } from '../util';\nexport default VNode;\n\n\nclass VNode {\n  /**\n   * @param {String} tagName a tag name. Must be specified.\n   * @param {Object} props can be an empty object.\n   * @param {Array} children can be an empty array.\n   */\n  constructor(tagName, props, children) {\n    this.tagName = tagName;\n    this.props = props;\n    this.children = children;\n    this.key = (props && props.key);\n    this.cleanups = []; // for cleaning up event listeners.\n    this.count = children && children.reduce((acc, child) => {\n      if (child instanceof VNode)\n        return child.count + acc + 1;\n      else\n        return acc + 1;\n    }, 0);\n    \n    if (this.key)\n      delete props.key; // no key will be needed anymore.\n  }\n\n  /**\n   * render a real DOM tree for this VTree rooted at this VNode.\n   */\n  render() {\n    const element = !(/(SVG|svg)/.test(this.tagName))\n      ? document.createElement(this.tagName)\n      : document.createElementNS(\n        \"http://www.w3.org/2000/svg\",\n        \"svg\"\n      );\n\n    const props = this.props;\n    const self = this;\n\n    for (const propName in props) {\n      if (props.hasOwnProperty(propName)) {\n        const _events = propName.match(eventHookRe);\n        if (_events) {\n          // FIXME: might be a better way of handling this.\n          try {\n            const handler = typeof props[propName] === 'function'\n              ? props[propName]\n              : new Function(`(${props[propName]})(...arguments);`);\n            \n            // store it for later detachment, to avoid memory\n            // leaking.\n            this.cleanups.push({\n              evName: _events[1],\n              handler: handler\n            });\n            // avoid bubbling.\n            element.addEventListener(_events[1], handler, false);\n          } catch(e) {\n            console.log(\n              `Warning: listener for event '${_event[1]}' isn't working.\n              If you're specifying this handler in string, please specify a function.`);\n          }\n        }\n        \n        else if (propName === 'className') {\n          element.setAttribute('class', props[propName])\n        }\n\n        else {\n          element.setAttribute(propName, props[propName]);\n        }\n      }\n    }\n\n    this.children.forEach(child => {\n      var childElement;\n\n      // It is a Text node.\n      if (typeof child === 'string') {\n        \n        childElement = document.createTextNode(child);  \n      }\n      // It is a VNode or custom node.\n      else if (child instanceof VNode ||\n        (child.render && typeof child.render === 'function')\n      ) {\n        childElement = child.render();\n      }\n\n      else {\n        throw new Error('Custom-defined node must provide a `render` method.');\n      }\n      element.appendChild(childElement);\n    });\n\n    this.$el = element;\n    return element;\n  }\n\n  detachEventListeners() {\n    this.cleanups.forEach(event => {\n      this.$el.removeEventListener(event.evName, event.handler);\n    });\n  }\n}","import VNode from '../vnode/index';\nimport { isArray, isEmpty } from '../util';\nexport default h;\n\n\nconst classIdSpliter = /([\\.#]?[^\\s#.]+)/;\nconst spaceStriper = /^\\s*|\\s*$/;\nconst propSpliter = /\\s*=\\s*/;\n\nfunction parseTagName(tagName) {\n  const parts = tagName.split(classIdSpliter);\n  const result = {};\n\n  parts.forEach(part => {\n    if (part === '')  return;\n\n    if (!result.tagName) {\n      result.tagName = part;\n    } else if (part[0] === '.') {\n      (result.className || (result.className = [])).push(part.substr(1));\n    } else if (part[0] === '#') {\n      result.id = part.substr(1);\n    }\n  });\n\n  result.className && result.className.join(' ');\n  return result;\n}\n\n/**\n * \n * @param {String|Function} tagName a built-in tag name or custom function that returns an object created by h.\n * @param {Object} props optional. any style, event listeners, and className should be put here.\n * @param {*} children optional children. Any string, instance of VNode will be children.\n */\nfunction h(tagName, props, ...children) {\n  var tagInfo, vnode;\n\n  if (typeof tagName === 'function') {\n    // use `new` in case it is a class.\n    return new tagName(props, ...children);\n  }\n\n  (props || (props = {}));\n  (children || (children = []));\n\n  // handle children re-maps.\n  if ((props instanceof VNode) ||\n      (typeof props === 'string')\n    ) {\n    children.unshift(props);\n    props = {};\n  }\n  \n  // handle children re-maps.\n  if (isArray(props)) {\n    children = [...props, children];\n    props = {};\n  }\n\n  // handle object-literal `style`.\n  if (props.style && typeof props.style === 'object') {\n    let style = '';\n\n    for (const key in props.style) {\n      style += `${key}: ${props.style[key]}; `;\n    }\n    props.style = style;\n  }\n\n  // handle array-literal `className`.\n  if (props.className && isArray(props.className)) {\n    props.className = props.className.join(' ');\n  }\n\n  if (typeof tagName === 'string') {\n    tagInfo = parseTagName(tagName);\n    if (tagInfo.className) {\n      (props.className || (props.className = ''));\n      props.className += ' ' + tagInfo.className;\n    }\n    if (tagInfo.id) {\n      props.id = props.id ? props.id : tagInfo.id;\n    }\n    // any children will be handled by VNode, remember there's no\n    // VText.\n    return new VNode(tagInfo.tagName, props, children);\n  } else {\n    throw new Error('The first parameter to `h` function must be a string or a function.')\n  }\n}","const REPLACE = 'REPLACE';\nconst REORDER = 'REORDER';\nconst PROPS = 'PROPS';\nconst TEXT = 'TEXT';\n\nconst patchType = {\n  REPLACE,\n  REORDER,\n  PROPS,\n  TEXT\n};\n\nexport default patchType;\n","import patchType from './patch-type';\nexport default diff;\n\n\nconst { REPLACE, REORDER, TEXT, PROPS } = patchType;\nfunction diff(oldList, newList, key) {\n  const oldListKeys = getKeys(oldList, key);\n  const newListKeys = getKeys(newList, key);\n  const oldListLength = oldList.length;\n  const newListLength = newList.length;\n  let diffed = oldList.slice();\n  let moves = [];\n\n  // Not a key was provied, don't diff.\n  if (noKeys(oldListKeys) && noKeys(newListKeys)) {\n    let op, start, end, index, inserted;\n\n    if (oldListLength === newListLength) {\n      return {\n        diffed,\n        moves\n      };\n    }\n\n    // Remove accessary nodes.\n    if (oldListLength > newListLength) {\n      op = 'REMOVE';\n      start = newListLength;\n      end = oldListLength;\n      diffed.splice(newListLength, oldListLength - newListLength);\n    }\n    \n    // Insert neccessary nodes.\n    else if (newListLength > oldListLength) {\n      op = 'INSERT';\n      start = oldListLength;\n      end = newListLength;\n      inserted = newList.slice(oldListLength);\n      diffed = [...diffed, ...inserted];\n    }\n\n    for (let i = start; i < end; i++) {\n      moves.push({\n        type: op,\n        index: i,\n        node: newList[i] || null  // It doesn't matter what.\n      });\n    }\n\n    return {\n      diffed,\n      moves\n    };\n\n  }\n  // record the move of the last element.\n  let indexDeltas = new Array(oldListLength).fill(0);\n  let _physicalIndex;\n\n  newListKeys.forEach((key, newIndex) => {\n    let _physicalIndex = oldListKeys.indexOf(key);\n\n    if (_physicalIndex === -1) {\n      // Element doesn't exist in `newList` yet. Tell it to\n      // insert it.\n      moves.push({\n        type: 'INSERT',\n        index: newIndex,\n        node: newList[newIndex]\n      });\n      diffed.splice(newIndex, 0, newList[newIndex]);\n\n      // positions of all unprocessed elements should take this delta.\n      indexDeltas[oldListLength - 1]++;\n    } else {\n      let oldIndex = _physicalIndex;\n\n      for (let i = oldListLength - 1; i >= _physicalIndex; i--) {\n        oldIndex += indexDeltas[i];\n      }\n\n      // If it is already in place, don't do anything.\n      if (newIndex === oldIndex)  return;\n\n      moves.push({\n        type: 'MOVE',\n        from: oldIndex, \n        to: newIndex\n      });\n      let _elem = diffed.splice(oldIndex, 1)[0];\n      diffed.splice(newIndex, 0, _elem);\n      newList[newIndex].$el = oldList[oldIndex].$el;\n\n      // It is impossible to move element from front to back.\n      indexDeltas[_physicalIndex]++;\n    }\n  });\n\n  // remove extra.\n  oldListKeys.forEach((key, i) => {\n    \n    if (newListKeys.indexOf(key) === -1) {\n      moves.push({\n        type: 'REMOVE',\n        index: newListLength,  // all extra items must've been moved to end.\n        node: diffed.splice(newListLength, 1)[0]\n      });\n    }\n  });\n\n  return {\n    diffed,\n    moves\n  };\n}\n\n// Elements with no `key` field is to be removed.\nfunction getKeys(list, key) {\n  return list.map((item, i) => {\n    if (key && item) {\n      return typeof key === 'function'\n        ? key(item)\n        : item[key];\n    } else  return void 0;\n  });\n}\n\n\nfunction noKeys(list) {\n  for (const item of list)\n    if (item !== void 0)\n      return false;\n\n  return true;\n}","import listDiff from './list-diff';\nimport { isEmpty } from '../util';\nimport patchType from './patch-type';\n\n\nconst { REPLACE, REORDER, TEXT, PROPS } = patchType;\n\nexport default function diff (oldTree, newTree) {\n  const patches = {};\n  walk(oldTree, newTree, patches, 0);\n  return patches;\n}\n\nfunction walk(oldNode, newNode, patches, index) {\n  var currPatches = [];\n  var propPatches, childrenPatches;\n\n  // TODO: let custom-defined component take control of diffing.\n\n  if (newNode === void 0) {\n    // oldNode will be removed.\n    return patches;\n  }\n\n  // both Text node.\n  else if (typeof oldNode === 'string' && typeof newNode === 'string') {\n\n    if (oldNode === newNode) {\n      // nothing to patch.\n    } else {\n      patches[index] = [{ type: TEXT, text: newNode }];\n    }\n    // there would be no props nor children.\n    return patches;\n  }\n\n  propPatches = diffProps(oldNode.props || {}, newNode.props || {});\n\n  // the whole node should be replaced, if tag names are not the same\n  // or keys diffed.splice(oldListLength, 0, ...inserted); are not the same.\n  if (oldNode.tagName !== newNode.tagName ||\n      oldNode.key !== newNode.key) {\n    \n      currPatches.push({\n        type: REPLACE,\n        node: newNode,\n        oldNode: oldNode  // for detaching event listeners.\n      });\n      patches[index] = currPatches;\n      // do not diff their children anymore.\n      return patches;\n  }\n  // only patch some props.\n  else if (!isEmpty(propPatches)) {\n    currPatches.push({\n      type: PROPS,\n      props: propPatches,\n      node: oldNode       // for detaching event listeners.\n    });\n    newNode.$el = oldNode.$el;\n  }\n\n  diffChildren(\n    oldNode.children || [],\n    newNode.children || [],\n    patches,\n    currPatches,\n    index\n  );\n  if (currPatches.length) {\n    patches[index] = currPatches;\n  }\n  return patches;\n}\n\nfunction diffProps(oldProps, newProps) {\n  var propPatches = {}, value;\n\n  // update props.\n  for (const propName in newProps) {\n    if (newProps.hasOwnProperty(propName)) {\n      value = newProps[propName];\n      if (oldProps[propName] !== value) {\n        propPatches[propName] = value;\n      }\n    }\n  }\n  // remove old props.\n  for (const propName in oldProps) {\n    if (!(propName in newProps))\n      propPatches[propName] = void 0;\n  }\n  return propPatches;\n}\n\n\nfunction diffChildren(oldChildren, \n  newChildren, patches, currPatches, index) {\n  const diffs = listDiff(oldChildren, newChildren, 'key');\n\n  oldChildren = diffs.diffed; // Must reorder them first before steppin deeper.\n  if (diffs.moves.length) {\n    currPatches.push({\n      type: REORDER,\n      moves: diffs.moves\n    });\n  }\n\n  var prevSibling = null;\n  var currIndex = index;\n  oldChildren.forEach((child, i) => {\n    const newChild = newChildren[i];\n    currIndex = (prevSibling && prevSibling.count)\n      ? prevSibling.count + currIndex + 1\n      : currIndex + 1;  // the first child.\n    walk(child, newChildren[i], patches, currIndex);\n    prevSibling = child;\n  });\n}","import VNode from '../vnode/index';\nimport patchType from '../diff/patch-type';\nimport { eventHookRe } from '../util';\nexport default patch;\n\n\nconst { REPLACE, REORDER, PROPS, TEXT } = patchType;\n\nfunction patch(domRoot, patches) {\n  walk(domRoot, patches, { index: 0 });\n}\n\n// walker keeps the complexity away.\n// `walk` updates the domTree buttom-up.\nfunction walk(domNode, patches, walker) {\n  const currPatches = patches[walker.index];\n  let   skipChildren = false;   // If it is a REPLACE patch, do not walk it.\n\n  // changes should be applied for this node first\n  if(currPatches) {\n    skipChildren = applyPatches(domNode, currPatches);\n  }\n\n  if (domNode.childNodes && !skipChildren) {\n    const childArr = [].slice.call(domNode.childNodes);\n    childArr.forEach((child, i) => {\n      walker.index++;\n      walk(child, patches, walker);\n    });\n  } else if (skipChildren) {\n    // don't forget to add them up.\n    walker.index += currPatches[0].oldNode.count;\n  }\n}\n\n\nfunction applyPatches(domNode, patches) {\n  let props, newNode, _events, skipChildren = false;\n\n  patches.forEach(patch => {\n    switch(patch.type) {\n    // FIXME: might be buggy.\n    case REPLACE:\n      newNode = (patch.node instanceof VNode || patch.node.render)\n        ? patch.node.render()\n        : typeof patch.node === 'string'\n        ? document.createTextNode(patch.node)\n        : new Error('You might be using a custom-defined node extended from VNode, if so, provide a render function.');\n      \n      if (newNode instanceof Error) {\n        throw newNode;\n      }\n\n      patch.oldNode.detachEventListeners();\n      domNode.parentNode.replaceChild(newNode, domNode);\n      skipChildren = true;\n      break;\n\n    case PROPS:\n      props = patch.props;\n      for (let propName in props) {\n        if ((_events = propName.match(eventHookRe))) {\n          // detach all event listeners added previously\n          patch.node.detachEventListeners();\n          if (typeof props[propName] === 'function')\n            domNode.addEventListener(_events[1], props[propName], false);\n        }\n\n        else if (props[propName] === void 0)\n          domNode.removeAttribute(propName !== 'className' ? propName : 'class');\n        else\n          domNode.setAttribute(propName !== 'className' ? propName : 'class', props[propName]);\n      }\n      break;\n\n    case TEXT:\n      if (domNode.textContent) {\n        domNode.textContent = patch.text;\n      } else {\n        domNode.nodeValue = patch.text;\n      }\n      break;\n    \n    case REORDER:\n      reorderChildren(domNode, patch.moves);\n      break;\n\n    default:\n      throw new Error('Some internal error.');\n    }\n  });\n\n  return skipChildren;\n}\n\n// TODO: Add batch.\nfunction reorderChildren(domNode, moves) {\n  const childNodes = domNode.childNodes;\n  let node;\n\n  moves.forEach(move => {\n  switch(move.type) {\n    case 'INSERT':\n      try {\n        node = move.node.render();\n        domNode.insertBefore(node, childNodes[move.index]);\n      } catch (e) {\n        console.log('You might be using a custom-defined node extended from VNode, if so, provide a render function.');\n      }\n      break;\n\n    case 'REMOVE':\n      domNode.removeChild(childNodes[move.index]);\n      move.node.detachEventListeners();\n      break;\n\n    case 'MOVE':\n      domNode.insertBefore(childNodes[move.from], childNodes[move.to]);\n      break;\n    }\n  });\n}"],"names":["isArray","obj","Object","prototype","toString","call","eventHookRe","VNode","tagName","props","children","key","cleanups","count","reduce","acc","child","this","element","test","document","createElementNS","createElement","propName","hasOwnProperty","_events","match","handler","Function","push","addEventListener","e","log","_event","setAttribute","forEach","childElement","createTextNode","render","Error","appendChild","$el","removeEventListener","event","evName","classIdSpliter","patchType","getKeys","list","map","item","i","noKeys","REPLACE","REORDER","TEXT","PROPS","walk","oldNode","newNode","patches","index","propPatches","currPatches","type","text","oldProps","newProps","value","diffProps","keys","length","oldChildren","newChildren","diffs","oldList","newList","oldListKeys","newListKeys","oldListLength","newListLength","diffed","slice","moves","op","start","end","splice","inserted","indexDeltas","Array","fill","newIndex","_physicalIndex","indexOf","oldIndex","_elem","listDiff","prevSibling","currIndex","tagInfo","unshift","style","_typeof","className","join","result","split","part","substr","id","parseTagName","oldTree","newTree","domRoot","domNode","walker","skipChildren","patch","node","detachEventListeners","parentNode","replaceChild","removeAttribute","textContent","nodeValue","childNodes","move","insertBefore","removeChild","from","to","applyPatches","childArr"],"mappings":"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"}