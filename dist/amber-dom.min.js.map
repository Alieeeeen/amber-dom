{"version":3,"file":"amber-dom.min.js","sources":["../src/util.js","../src/vnode.js","../src/h.js","../src/dom-manager.js","../src/patch.js"],"sourcesContent":["// Some helper functions.\nexport function isArray (obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\nexport function isEmpty(obj) {\n  return Object.keys(obj|| {}).length === 0;\n}\n\n// Some constants or Regex.\nexport const eventHookRe = /^ev\\-([a-z]+)/;\nexport const svgRe = /(svg|SVG)/;\nexport const xlinkRe = /^xlink:(.*)$/;\nexport const SVG_NS = 'http://www.w3.org/2000/svg';\nexport const XLINK_NS = 'http://www.w3.org/1999/xlink';\n","import { eventHookRe, svgRe, SVG_NS } from './util';\nexport default VNode;\n\n/**\n * Add namespace for `vnode` and recursively add it to its children.\n * @param {VNode} vnode A vnode.\n * @param {String} ns A namespace.\n */\nfunction addNS(vnode, ns) {\n  const children = vnode.children;\n  vnode.ns = ns;\n  // tag name needs to be converted back to lowercase.\n  vnode.tagName = vnode.tagName\n    ? vnode.tagName.toLocaleLowerCase() : void 0;\n\n  for (let i = 0, len = children.length; i < len; i++) {\n    let child = children[i];\n\n    if (child instanceof VNode) {\n      addNS(child, ns);\n    }\n  }\n}\n\n/**\n * Ensure all children have keys. If no key is provided,\n * use index instead.\n * @param {Array} children \n */\nfunction addChildKeys(children) {\n  let ch;\n\n  for (let i = 0, len = children.length; i < len; i++) {\n    ch = children[i];\n\n    if (ch instanceof VNode) {\n      ch.key = ch.props.key = ch.props.key != null\n        ? ch.props.key : i;\n    }\n  }\n}\n\nclass VNode {\n  /**\n   * @param {String} tagName a tag name. Must be specified.\n   * @param {Object|null} props can be an empty object.\n   * @param {Array|null} children can be an empty array.\n   */\n  constructor(tagName, props, children) {\n    this.tagName = tagName.toUpperCase();\n    this.props = props || {};\n    this.children = children || [];\n    this.key = props && props.key;\n\n    let i,\n        ns = (props && props.namespace) || (svgRe.test(tagName) ? SVG_NS : void 0);\n\n    // set up namespace.\n    if (ns) {\n      addNS(this, ns);\n    }\n\n    // set up children's key.\n    addChildKeys(this.children);\n\n    // set up hooks.\n    if (props.hooks) {\n      this.hooks = i = props.hooks;\n      delete props.hooks;\n      // if `vnode hook` is defined, invoke it with this vnode.\n      if ((i = i.vnode) || typeof i === 'function')\n        i(vnode);\n    }\n  }\n}","import VNode from './vnode';\nimport { isArray } from './util';\nexport default h;\n\n\nconst classIdSpliter = /([\\.#]?[^\\s#.]+)/;\nconst spaceStriper = /^\\s*|\\s*$/;\nconst propSpliter = /\\s*=\\s*/;\nconst stack = [];   // internal stack for parsing children.\n\n/**\n * A selector might contain a tag name followed by some CSS selector.\n * This function was stripped and modiffied from hyperscript's  parseClass.\n * @see https://github.com/hyperhype/hyperscript/blob/master/index.js\n * @param {String} selector \n */\nfunction parseSelector(selector) {\n  const parts = selector.split(classIdSpliter);\n  const result = {};\n\n  parts.forEach(part => {\n    if (part === '')  return;\n\n    if (!result.tagName) {\n      result.tagName = part;\n    } else if (part[0] === '.') {\n      (result.className || (result.className = [])).push(part.substr(1));\n    } else if (part[0] === '#') {\n      result.id = part.substr(1);\n    }\n  });\n\n  result.className && (result.className = result.className.join(' '));\n  return result;\n}\n\n/**\n * Original propto: h(selector, props, ...children).\n * \n * Found a more elegant way to handle children. Referred to Hyperapp's `h` function, which is dead simple. \n * @see https://github.com/hyperapp/hyperapp/blob/master/src/index.js\n * @param {String|Function} selector a built-in tag name or custom function that returns an object created by h.\n * @param {Object} props optional. any style, event listeners, and className should be put here.\n * @param {*} rest optional children. Can be nested.\n */\nfunction h(selector, props) {\n  // Case 1: `selector` is a function.\n  if (typeof selector === 'function') {\n    // use `new` in case it is a class.\n    return new selector(...Array.prototype.slice.call(arguments, 1));\n  }\n\n  let tagInfo, children = [], child, lastPrimitive = false;\n\n  (props || (props = {}))\n\n  // collect children\n  for (let i = arguments.length; i-- > 2; ) {\n    stack.push(arguments[i]);\n  }\n\n  // if props is any of these below, it must be a child.\n  if ((props instanceof VNode) ||\n    (typeof props === 'string') ||\n    (typeof props === 'number') ||\n    (typeof props === 'boolean') ||\n    (isArray(props))\n  ) {\n    stack.push(props);\n    props = {};\n  }\n\n  // handle nested children if there's any.\n  while (stack.length) {\n    if ((child = stack.pop()) && child.pop !== void 0) {\n      for (let i = child.length; i--;)  stack.push(child[i]);\n    }\n\n    else {\n      child = child == null ? '' : child;\n      child = typeof child === 'boolean' ? '' : child;\n      child = typeof child === 'number' ? String(child) : child;\n\n      if (lastPrimitive && typeof child === 'string') {\n        children[children.length - 1] += child;\n      }\n\n      else {\n        children.push(child);\n        lastPrimitive = typeof child === 'string' ? true : false;\n      }\n    }\n  }\n\n  // Case 2: `selector` is 'text'. \n  if (selector === 'text') {\n    return children.length === 0\n      ? ''\n      : children.join('');\n  }\n\n  // Case 3: `selector` is a selector.\n  else if (typeof selector === 'string') {\n    if (props.className && isArray(props.className)) {\n      props.className = props.className.join(' ');\n    }\n\n    tagInfo = parseSelector(selector);\n    if (tagInfo.className) {\n      props.className = props.className\n        ? props.className + ' ' + tagInfo.className\n        : tagInfo.className;\n    }\n\n    if (tagInfo.id) {\n      props.id = props.id ? props.id : tagInfo.id;\n    }\n\n    return new VNode(tagInfo.tagName, props, children);\n  }\n  \n  else {\n    throw new Error(`Unrecognized selector: ${selector}.`)\n  }\n}","import { eventHookRe, XLINK_NS, xlinkRe } from \"./util\";\nimport VNode from './vnode';\n\nexport default domManager;\n\n// dom mangager. Used internally.\nconst domManager = {\n  append,\n  insertBefore,\n  remove,\n  create,\n  setAttribute,\n  emptyChildren\n};\n\n/**\n * @param {Element} parentNode \n * @param {Element} node \n */\nexport function append(parentNode, node) {\n  parentNode.appendChild(node);\n}\n\n/**\n * @param {Element} parentNode\n * @param {Element} node \n * @param {Element} domNode the reference node.\n */\nexport function insertBefore(parentNode, node, domNode) {\n  parentNode.insertBefore(node, domNode);\n}\n\n/**\n * Remove a child on a node if it exists.\n * @param {Element} parentNode the parent of the node to be removed.\n * @param {Element} domNode the node to be removed.\n * @param {Element} node Optional replacement of `domNode`.\n */\nexport function remove(parentNode, domNode, node) {\n  let i, res, hooks = domNode.$hooks;\n\n  if (parentNode && domNode.parentNode === parentNode) {\n    if (hooks && (i = hooks.beforeRemove) && (typeof i === 'function')) {\n      if (i(domNode) === false)\n        return;\n    }\n    \n    (node) && (parentNode.replaceChild(node, domNode)) && (res = node);\n    (parentNode.removeChild(domNode)) && (res = domNode);\n    \n    if (hooks && (i = hooks.removed) && (typeof i === 'function')) {\n      i(domNode);\n    }\n  }\n\n  else if (domNode && node) {\n    res = node;\n  }\n\n  else {\n    console.warn(`The element ${node.id ? node.tagName+'#'+node.id : node.tagName} wasn't mounted on document.`)\n  }\n  \n  return res;\n}\n\n/**\n * Create a DOM node represented by `vnode`\n * @param {String|Number|VNode} vnode \n */\nexport function create(vnode) {\n  // create a text node if it is a string or a number.\n  if (typeof vnode === 'string' || typeof vnode === 'number')\n    return document.createTextNode(vnode);\n\n  const tagName = vnode.tagName,\n        props = vnode.props,\n        children = vnode.children,\n        ns = vnode.ns,\n        element = ns\n          ? document.createElementNS(ns, tagName)\n          : document.createElement(tagName);\n\n  let i;\n\n  // for next diff.\n  element.$props = props;\n  for (const propName in props) {\n    const event = propName.match(eventHookRe);\n    if (event) {\n      const handler = typeof props[propName] === 'function'\n        ? props[propName]\n        : new Error(`Handler to ${event[1]} is not a function`);\n\n      if (handler instanceof Error) {\n        console.warn(`Failed to add listener for ${event[1]}: ${handler.message}`);\n      }\n\n      // for next diff.\n      (element.$listeners || (element.$listeners = {}))[event[1]] = handler;\n      element.addEventListener(event[1], handler, false);\n    }\n\n    else {\n      setAttribute(element, propName, props[propName], !!ns);\n    }\n  }\n\n  children.forEach((child, i) => {\n    let childElement;\n\n    if (child instanceof VNode || typeof child === 'string') {\n      childElement = create(child);\n    }\n\n    // TODO: add thunk.\n\n    else {\n      console.warn(`Unrecognizable node: ${child}`);\n    }\n\n    element.appendChild(childElement);\n  });\n\n  // Invoke \"created hooks\"\n  if ((i = vnode.hooks) && (i = i.created) && (typeof i === 'function')) {\n    i(element);\n  }\n  element.$hooks && (element.$hooks = vnode.hooks);\n  delete props.$hooks;\n\n  return element;\n}\n\n/**\n * Set attribute/property on an element.\n * @param {Element} element \n * @param {String} attrName \n * @param {String} value \n */\nexport function setAttribute(element, attrName, value, isNameSpaced) {\n  let ns, oldValue;\n\n  attrName = attrName === 'className' ? 'class' : attrName;\n\n  switch(attrName) {\n  case 'key':\n    element.key = value;\n    break;\n  \n  case 'style':   /** if style is an object, it'll always be patched. */\n    oldValue = element.$style;\n\n    if (!value || typeof value === 'string' || typeof oldValue === 'string') {\n      // if `value` is an object, it will be reset below.\n      element.style.cssText = value || '';\n    }\n    \n    if (value && typeof value === 'object') {\n      // set every old style field to empty.\n      if (typeof oldValue !== 'string') {\n        for (let i in oldValue) {\n          if (!(i in value))\n            element.style[i] = '';\n        }\n      }\n      \n      // you might be wondering why don't I compare the value before setting\n      // it. In fact, no comparison is needed because it won't cause the browser's\n      // repaint or reflow if the new value is the same as old one.\n      for (let i in value) {\n        element.style[i] = value[i];\n      }\n    }\n\n    // for next diff.\n    value && (element.$style = value);\n\n    break;\n  \n  case 'class':\n    element.className = value || '';\n    break;\n\n  case 'children':\n    console.warn(`Failed to set \"children\" on element ${element.tagName}.`);\n    break;\n\n  case 'innerHTML':\n    console.warn(`Failed to set \"innerHTML\" on a \"${element.tagName.toLocaleLowerCase()}\".`);\n    break;\n\n  default:\n    if (!isNameSpaced && (attrName in element) && (attrName !== 'type')) {\n      // set it as a property.\n      try {\n        element[attrName] = value ? value : '';\n      } catch(e) {\n        console.warn(`Failed to set attribute: ${attrName} on element \"${element.id ? element.tagName + element.id : element.tagName }\"`)\n      }\n\n      if (value == null) {\n        element.removeAttribute(attrName);\n      }\n    }\n\n    else {\n      ns = isNameSpaced && !!(attrName.match(xlinkRe));\n      // set it as an attribute.\n      if (value && ns) {\n        element.setAttributeNS(XLINK_NS, attrName, value);\n      } else if (!value && ns) {\n        element.removeAttributeNS(XLINK_NS, attrName);\n      } else if (value) {\n        element.setAttribute(attrName, value);\n      } else {\n        element.removeAttribute(attrName);\n      }\n    }\n  }\n}\n\n/**\n * Empty an element's children.\n * Removing from the last child might cause less repaint and reflow.\n * @param {Element} element \n */\nexport function emptyChildren(element) {\n  if (element && element.childNodes && element.childNodes.length) {\n    let fc = element.firstChild, lc = element.lastChild;\n\n    while(fc !== lc) {\n      remove(element, lc);\n      lc = element.lastChild;\n    }\n    remove(element, fc);\n  }\n}","import VNode from './vnode';\nimport { eventHookRe, isEmpty } from './util';\nimport { \n  setAttribute,\n  insertBefore,\n  create,\n  remove,\n  append,\n  emptyChildren } from \"./dom-manager\";\n\nexport default patch;\n\n\n/**\n * @param {Element|Text} domRoot \n * @param {VNode} vRoot \n */\nfunction patch(domRoot, vRoot) {\n  if (domRoot instanceof Element || domRoot instanceof Text) {\n    domRoot = patchElement(domRoot, vRoot);\n  }\n  return domRoot;\n}\n\n\n/**\n * Patch a DOM node with a vnode.\n * @param {Element|Text} element \n * @param {VNode} vnode \n * @param {Boolean} same If 2 nodes are already checked by `isSameNode`, it should be set true.\n */\nfunction patchElement(element, vnode, same) {\n  let i, hooks = element.$hooks;\n\n  if (vnode == null || typeof vnode === 'boolean')\n    vnode = '';\n\n  // 1. both text nodes.\n  if (\n    (element.nodeType === 3) &&\n    (typeof vnode === 'string' || typeof vnode === 'number')\n  ) {\n    const oldText = element.textContent || element.nodeValue;\n    if (oldText !== vnode)\n      element.textContent = vnode;\n  }\n  \n  // 2. are the same node.\n  else if (same || isSameNode(element, vnode)) {\n    if (hooks && (i = hooks.beforeUpdate) && (typeof i === 'function')) {\n      if(i(element, vnode) === false)\n        return;\n    }\n\n    patchProps(element, vnode);\n\n    if (hooks && (i = hooks.updated) && (typeof i === 'function')) {\n      i(element, vnode);\n    }\n\n    patchChildren(element, vnode);\n  }\n\n\n  // 3. not the same node.\n  else {\n    let node = create(vnode);\n    // replace the `element` with `node`.\n    element = remove(element.parentNode, element, node);\n  }\n\n  return element;\n}\n\n/**\n * See if 2 nodes are of the same type & have the same key.\n * Text nodes will do find because it will be patched by `patchedElement` eventually.\n * @param {Element|Text} element \n * @param {VNode} vnode \n */\nfunction isSameNode(element, vnode) {\n  return element.key === vnode.key && element.tagName === vnode.tagName;\n}\n\n/**\n * Patch 2 nodes' props/attributes.\n * @param {Element} element \n * @param {VNode} vnode \n */\nfunction patchProps(element, vnode) {\n  let attrs = vnode.props,\n      old = element.$props,\n      isSvg = !!element.ns;\n\n  // if this dom node wasn't diffed before, or wasn't created\n  // by `create`, pull out its attributes and patch them.\n  if (old == null || isEmpty(old)) {\n    old = element.$props = old == null ? {}: old;\n    for (let a = element.attributes, i = a.length; i--; ) {\n      old[a[i].name] = a[i].value;\n    }\n  }\n\n  // remove attributes not on vnode.\n  for(const name in old) {\n    if (old[name] && !(attrs && attrs[name])) {\n      setAttribute(element, name, (old[name] = void 0), isSvg);\n    }\n  }\n\n  // add new & update attributes.\n  // Don't worry about style object,\n  // because `setAttribute` will deal with it.\n  for (const name in attrs) {\n    if (!(name in old) || attrs[name] !== (\n      name === 'value' || name === 'checked' ? element[name] : old[name])\n    ) {\n      setAttribute(element, name, attrs[name], isSvg);\n    }\n  }\n}\n\n/**\n * Patch an element's children\n * @param {Element} element \n * @param {VNode} vnode \n */\nfunction patchChildren(element, vnode) {\n  const oldChildren = element.childNodes,\n        vChildren = vnode.children,\n        oldLen = oldChildren.length,\n        vLen = vChildren.length;\n  \n  // nothing to patch.\n  if (vLen === 0 && oldLen === 0) {\n    return;\n  }\n\n  // Special case: if vnode contains only 1 child.\n  else if (vLen === 1) {\n    let ch = vChildren[0],\n        elemToMove;\n\n    if (oldLen === 1 && isSameNode(oldChildren[0], ch)) {\n      patchElement(oldChildren[0], ch, true);\n    }\n\n    else {\n      // Try to find a child node that match.\n      for (let i = 1; i < oldLen; i++) {\n        if (isSameNode(oldChildren[i], ch)) {\n          patchElement(oldChildren[i], ch, true);\n\n          elemToMove = oldChildren[i];\n          break;\n        }\n      }\n\n      // If it wasn't found, create one from the vnode.\n      if (elemToMove === void 0) {\n        elemToMove = create(ch);\n      }\n      emptyChildren(element);\n      element.appendChild(elemToMove);\n    }\n  }\n\n  // case 1: both have children.\n  else if (oldLen !== 0 && vLen > 1) {\n    let keyedChildren,\n        vStart = 0,\n        vEnd = vLen - 1,\n\n        oldStartCh = element.firstChild,\n        oldEndCh = element.lastChild,\n\n        vStartCh = vChildren[vStart],\n        vEndCh = vChildren[vEnd],\n\n        elemToMove;\n\n    while(vStart <= vEnd && oldStartCh !== oldEndCh) {\n      while(vStart <= vEnd && oldStartCh !== oldEndCh && \n        oldStartCh && vStartCh && isSameNode(oldStartCh, vStartCh)\n      ) {\n        patchElement(oldStartCh, vStartCh, true);\n\n        oldStartCh = oldStartCh.nextSibling;\n        vStartCh = vChildren[++vStart];\n      }\n\n      while(vStart <= vEnd && oldStartCh !== oldEndCh && \n        oldEndCh && vEndCh && isSameNode(oldEndCh, vEndCh)\n      ) {\n        patchElement(oldEndCh, vEndCh, true);\n\n        oldEndCh = oldEndCh.previousSibling;\n        vEndCh = vChildren[--vEnd];\n      }\n\n      // in case there is no reordering, but just some insertions or removals.\n      if (oldStartCh === oldEndCh || vStart >= vEnd)  break;\n\n      // Reorder corner case 1.\n      if (isSameNode(oldStartCh, vEndCh)) {\n        patchElement(oldStartCh, vEndCh, true);\n        elemToMove = oldStartCh;\n        oldStartCh = oldStartCh.nextSibling;\n        // place it right behind oldEndCh.\n        insertBefore(element, elemToMove, oldEndCh.nextSibling);\n\n        vEndCh = vChildren[--vEnd];\n      }\n\n      // Reorder corner case 2.\n      else if (isSameNode(oldEndCh, vStartCh)) {\n        patchElement(oldEndCh, vStartCh, true);\n        elemToMove = oldEndCh;\n        oldEndCh = oldEndCh.previousSibling;\n        // place it right in front of oldStartCh.\n        insertBefore(element, elemToMove, oldStartCh);\n\n        vStartCh = vChildren[++vStart];\n      }\n\n      // insert or reorder.\n      else {\n        // try to find element in old list.\n        if (keyedChildren == null) {\n          keyedChildren = createKeyMap(oldChildren, oldStartCh, oldEndCh);\n        }\n        \n        elemToMove = keyedChildren[vStartCh.key];\n\n        // not found. Create a new child.\n        if (elemToMove == null) {\n          elemToMove = create(vStartCh);\n          // place it right in front of oldStartCh\n          insertBefore(element, elemToMove, oldStartCh);\n        }\n        // found. Move it to its place.\n        else {\n          patchElement(elemToMove, startChild);\n          keyedChildren[elemToMove.key] = void 0;\n          // place it right in front of oldStartCh\n          insertBefore(element, elemToMove, oldStartCh);\n        }\n        vStartCh = vChildren[++vStart];\n      }\n    }\n\n    // NOTE: The outer if might be unnecessary.\n    // if oldStartCh is ahead of oldEndCh or is oldEndCh\n    if (vStart <= vEnd || oldStartCh !== oldEndCh || oldStartCh === oldEndCh) {\n      if (oldStartCh) {\n\n        // oldStartCh is ahead of oldEndCh, which means\n        // there are children to be removed.\n        while(oldStartCh !== oldEndCh) {\n          elemToMove = oldStartCh;\n          oldStartCh = oldStartCh.nextSibling;\n          remove(element, elemToMove);\n        }\n\n        if (isSameNode(oldEndCh, vChildren[vEnd])) {\n          patchElement(oldEndCh, vChildren[vEnd], true);\n          if (vStart === vEnd) {\n            return;\n          }\n          vEnd--;\n        }\n\n        else {\n          elemToMove = oldEndCh;\n          oldEndCh = oldEndCh.nextSibling;\n          remove(element, elemToMove);\n        }\n\n        // append new children if there's any.\n        for (let i = vStart; i <= vEnd; i++) {\n          insertBefore(element, create(vChildren[i]), oldEndCh);\n        }\n      }\n    }\n  }\n\n  // case 2: remove all DOM children.\n  else if (oldLen !== 0) {\n    emptyChildren(element);\n  }\n\n  // case 3: insert new DOM children.\n  else if (vLen !== 0) {\n    let newCh;\n\n    for (let i = 0, newCh = vChildren[0]; i < vLen; i++) {\n      element.appendChild(create(newCh));\n    }\n  }\n}\n\n/**\n * Create a map of keyed children.\n * @param {NodeList} children\n * @param {Node} start the node to start from.\n * @param {Node} end  the node to end with\n * @returns { {key: Node} } a map with key equals key, value equals a node associated with this key.\n */\nfunction createKeyMap(children, start, end) {\n  const keyedChildren = {};\n\n  if (start === end && start.key) {\n    keyedChildren[String(start.key)] = start;\n  }\n\n  while(start !== end) {\n    if (start.key != null) {\n      keyedChildren[String(start.key)] = start;\n    }\n    start = start.nextSibling;\n  }\n\n  if (start === end && start.key) {\n    keyedChildren[String(start.key)] = start;\n  }\n\n  return keyedChildren;\n}"],"names":["isArray","obj","Object","prototype","toString","call","eventHookRe","svgRe","xlinkRe","SVG_NS","XLINK_NS","VNode","tagName","props","children","toUpperCase","key","i","ns","namespace","test","addNS","vnode","toLocaleLowerCase","len","length","child","this","ch","hooks","classIdSpliter","stack","insertBefore","parentNode","node","domNode","remove","res","$hooks","beforeRemove","replaceChild","removeChild","removed","warn","id","create","document","createTextNode","element","createElementNS","createElement","$props","propName","event","match","handler","Error","message","$listeners","addEventListener","forEach","childElement","appendChild","created","setAttribute","attrName","value","isNameSpaced","oldValue","$style","style","cssText","className","e","removeAttribute","setAttributeNS","removeAttributeNS","emptyChildren","childNodes","fc","firstChild","lc","lastChild","patchElement","same","nodeType","isSameNode","beforeUpdate","attrs","old","isSvg","keys","a","attributes","name","updated","oldChildren","vChildren","oldLen","vLen","elemToMove","keyedChildren","vStart","vEnd","oldStartCh","oldEndCh","vStartCh","vEndCh","nextSibling","previousSibling","createKeyMap","startChild","newCh","textContent","nodeValue","start","end","String","selector","Array","slice","arguments","tagInfo","lastPrimitive","push","pop","join","result","split","part","substr","parseSelector","domRoot","vRoot","Element","Text"],"mappings":"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"}