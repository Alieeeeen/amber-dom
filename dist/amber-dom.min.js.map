{"version":3,"file":"amber-dom.min.js","sources":["../src/util.js","../src/modules/events.js","../src/modules/style.js","../src/module-manager.js","../src/vnode.js","../src/h.js","../src/dom-manager.js","../src/patch.js"],"sourcesContent":["// Some helper functions.\nexport function isArray (obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\n// Some constants or Regex.\nexport const svgRe = /(svg|SVG)/;\nexport const xlinkRe = /^xlink:(.*)$/;\nexport const SVG_NS = 'http://www.w3.org/2000/svg';\nexport const XLINK_NS = 'http://www.w3.org/1999/xlink';\n","export default {\n  name: 'events',\n  creating: addEventListeners,\n  updating: addEventListeners\n}\n\n\nfunction addEventListeners(elem, events) {\n  let handler, params, value;\n\n  for (let name in events) {\n    value = events[name];\n\n    // a single listener\n    if (typeof value === 'function') {\n      handler = value;\n    }\n\n    // a listener with params.\n    else if (!!(value.shift) && (handler = value.shift()) && (typeof handler === 'function')) {\n      params = value;\n    }\n\n    // remove a listener.\n    else if ( value === void 0 ) {\n      handler = void 0;\n      params = void 0;\n    }\n\n    else {\n      console.warn(`Failed to add ${name} listener.`);\n      continue;\n    }\n\n    (elem.__listeners__ || (elem.__listeners__ = {}))[name] = { handler, params };\n    elem.addEventListener(name, proxyEvents);\n  }\n}\n\nfunction proxyEvents(ev) {\n  let handler, params,\n      elem = ev.currentTarget,\n      listeners = elem.__listeners__;\n\n  if (listeners && (handler = listeners[ev.type])) {\n    params = handler.params;\n    handler = handler.handler;\n\n    handler && params && handler(ev, params);\n    handler && handler(ev);\n  }\n}","export default {\n  name: 'style',\n  creating: updateInlineStyle,\n  updating: updateInlineStyle\n}\n\n\nfunction updateInlineStyle(elem, style) {\n  let oldStyle = elem.__style__;\n\n  if (!style || typeof style === 'string' || typeof oldStyle === 'string') {\n    elem.style.cssText = style || '';\n  }\n  \n  if (style && typeof style === 'object') {\n    // set every old style field to empty.\n    if (typeof oldStyle !== 'string') {\n      for (let i in oldStyle) {\n        if (!(i in value))\n          element.style[i] = '';\n      }\n    }\n    \n    for (let i in value) {\n      element.style[i] = value[i];\n    }\n  }\n\n  elem.__style__ = style;\n}","import events from './modules/events';\nimport style from './modules/style';\n\n\nexport let modules = {\n  events,\n  style\n};\n\n/**\n * Add an array of modules.\n * @param {Array} mods an array of modules to add.\n */\nexport function addModule(mods) {\n  if (!!mods.pop) {\n    for (let mod in mods) {\n      if (isMod(mod))\n        modules[mod.name] = mod;\n      else\n        console.warn(`Unrecognizable module: ${mod}`);\n    }\n  }\n\n  else {\n    console.warn(`Unrecognizable modules: ${mods}`);\n  }\n}\n\n/**\n * Initialize modules.\n * @param {Array} mods an array of modules.\n */\nexport function initModule(mods) {\n  modules = [];\n  addModule(mods);\n}\n\n\nfunction isMod(obj) {\n  return\n    (obj != null) && (obj.name) &&\n    obj.creating && (typeof obj.creating === 'function') &&\n    obj.updating && (typeof obj.updating === 'function');\n}","import { svgRe, SVG_NS } from './util';\nimport { modules } from './module-manager';\nexport default VNode;\n\n\n/**\n * Add namespace for `vnode` and recursively add it to its children.\n * @param {VNode} vnode A vnode.\n * @param {String} ns A namespace.\n */\nfunction addNS(vnode, ns) {\n  const children = vnode.children;\n\n  vnode.ns = ns;\n  for (let i = 0, len = children.length; i < len; i++) {\n    let child = children[i];\n\n    if (child instanceof VNode && child.tagName !== 'foreignObject') {\n      addNS(child, ns);\n    }\n  }\n}\n\nclass VNode {\n  /**\n   * @param {String} tagName a tag name. Must be specified.\n   * @param {Object|null} attrs attributes to set on DOM.\n   * @param {Array|null} children can be an empty array.\n   */\n  constructor(tagName, attrs, children) {\n    (attrs || (attrs = {}));\n    (children || (children = []));\n\n    let ns = (attrs.namespace) || (svgRe.test(tagName) ? SVG_NS : void 0);\n\n    this.tagName = !!ns ? tagName : tagName.toUpperCase();\n    this.attrs = {};\n    this.modAttrs = {};\n    this.key = attrs.key;\n    this.children = children;\n\n    // separate module-managed attrs and self-managed attrs.\n    for (let name in attrs) {\n      if (!(name in modules)) {\n        this.attrs[name] = attrs[name];\n      } else {\n        this.modAttrs[name] = attrs[name];\n      }\n    }\n\n    // set up namespace.\n    ns && addNS(this, ns);\n  }\n}","import VNode from './vnode';\nimport { isArray } from './util';\nexport default h;\n\n\nconst classIdSpliter = /([\\.#]?[^\\s#.]+)/;\nconst spaceStriper = /^\\s*|\\s*$/;\nconst propSpliter = /\\s*=\\s*/;\nconst stack = [];   // internal stack for parsing children.\n\n/**\n * A selector might contain a tag name followed by some CSS selector.\n * This function was stripped and modiffied from hyperscript's  parseClass.\n * @see https://github.com/hyperhype/hyperscript/blob/master/index.js\n * @param {String} selector \n */\nfunction parseSelector(selector) {\n  const parts = selector.split(classIdSpliter);\n  const result = {};\n\n  parts.forEach(part => {\n    if (part === '')  return;\n\n    if (!result.tagName) {\n      result.tagName = part;\n    } else if (part[0] === '.') {\n      (result.className || (result.className = [])).push(part.substr(1));\n    } else if (part[0] === '#') {\n      result.id = part.substr(1);\n    }\n  });\n\n  result.className && (result.className = result.className.join(' '));\n  return result;\n}\n\n/**\n * Original propto: h(selector, props, ...children).\n * \n * @param {String|Function} selector a built-in tag name or custom function that returns an object created by h.\n * @param {Object} attrs optional. any style, event listeners, and className should be put here.\n * @param {*} rest optional children. Can be nested.\n */\nfunction h(selector, attrs) {\n  // Case 1: `selector` is a function.\n  if (typeof selector === 'function') {\n    // use `new` in case it is a class.\n    return new selector(...Array.prototype.slice.call(arguments, 1));\n  }\n\n  let tagInfo, children = [], child, lastPrimitive = false;\n\n  (attrs || (attrs = {}))\n\n  // collect children\n  for (let i = arguments.length; i-- > 2; ) {\n    stack.push(arguments[i]);\n  }\n\n  // if attrs is any of these below, it must be a child.\n  if ((attrs instanceof VNode) ||\n    (typeof attrs === 'string') ||\n    (typeof attrs === 'number') ||\n    (typeof attrs === 'boolean') ||\n    (isArray(attrs))\n  ) {\n    stack.push(attrs);\n    attrs = {};\n  }\n\n  // handle nested children if there's any.\n  let idxKey = 0;\n  while (stack.length) {\n    if ((child = stack.pop()) && child.pop !== void 0) {\n      for (let i = child.length; i--;)  stack.push(child[i]);\n    }\n\n    else {\n      child = child == null ? '' : child;\n      child = typeof child === 'boolean' ? '' : child;\n      child = typeof child === 'number' ? String(child) : child;\n\n      if (lastPrimitive && typeof child === 'string') {\n        children[children.length - 1] += child;\n      }\n\n      else {\n        if (child instanceof VNode && (child.attrs.key == null)) {\n          child.key = child.attrs.key = idxKey++;\n        }\n        children.push(child);\n        lastPrimitive = typeof child === 'string' ? true : false;\n      }\n    }\n  }\n\n  // Case 2: `selector` is 'text'. \n  if (selector === 'text') {\n    return children.length === 0\n      ? ''\n      : children.join('');\n  }\n\n  // Case 3: `selector` is a selector.\n  else if (typeof selector === 'string') {\n    if (attrs.className && isArray(attrs.className)) {\n      attrs.className = attrs.className.join(' ');\n    }\n\n    tagInfo = parseSelector(selector);\n    if (tagInfo.className) {\n      attrs.className = attrs.className\n        ? attrs.className + ' ' + tagInfo.className\n        : tagInfo.className;\n    }\n\n    if (tagInfo.id) {\n      attrs.id = attrs.id ? attrs.id : tagInfo.id;\n    }\n\n    return new VNode(tagInfo.tagName, attrs, children);\n  }\n  \n  else {\n    throw new Error(`Unrecognized selector: ${selector}.`)\n  }\n}","import { XLINK_NS, xlinkRe } from \"./util\";\nimport { modules } from './module-manager';\nimport VNode from './vnode';\n\n\n/**\n * @param {Element} parentNode \n * @param {Element} node \n */\nexport function append(parentNode, node) {\n  parentNode.appendChild(node);\n}\n\n/**\n * @param {Element} parentNode\n * @param {Element} node \n * @param {Element} domNode the reference node.\n */\nexport function insertBefore(parentNode, node, domNode) {\n  parentNode.insertBefore(node, domNode);\n}\n\n/**\n * Remove a child on a node if it exists.\n * @param {Element} parentNode the parent of the node to be removed.\n * @param {Element} domNode the node to be removed.\n * @param {Element} node Optional replacement of `domNode`.\n */\nexport function remove(parentNode, domNode, node) {\n  let res;\n\n  if (parentNode && domNode.parentNode === parentNode) {\n    node && parentNode.replaceChild(node, domNode) && (res = node);\n    parentNode.removeChild(domNode) && (res = domNode);\n  }\n\n  else if (domNode && node) {\n    res = node;\n  }\n\n  return res;\n}\n\n/**\n * Create a DOM node represented by `vnode`\n * @param {String|Number|VNode} vnode \n */\nexport function create(vnode) {\n\n  if (typeof vnode === 'string')\n    return document.createTextNode(vnode);\n\n  let i;\n  const ns = vnode.ns,\n        attrs = vnode.attrs,\n        modAttrs = vnode.modAttrs,\n        tagName = vnode.tagName,\n        children = vnode.children,\n        elem = ns\n          ? document.createElementNS(ns, tagName)\n          : document.createElement(tagName);\n\n\n  elem.__attrs__ = attrs;\n  for (const name in attrs) {\n    setAttribute(elem, name, attrs[name]);\n  }\n\n  children.forEach((child, i) => {\n    let childElement;\n\n    if (child instanceof VNode || typeof child === 'string') {\n      childElement = create(child);\n    }\n\n    // TODO: add thunk.\n\n    else {\n      console.warn(`Unrecognizable node: ${child}`);\n    }\n\n    elem.appendChild(childElement);\n  });\n\n  for (const name in modAttrs) {\n    modules[name].creating(modAttrs[name]);\n  }\n\n  return elem;\n}\n\nexport function setAttribute(elem, name, value) {\n  let msg, isNS = !!(elem.tagName === 'svg');\n\n  switch(name) {\n    case 'key':\n      elem.__key__ = value;\n      break;\n\n    case 'namespace':\n      break;\n\n    case 'children':\n    case 'innerHTML':\n      msg = failMsg(elem, name);\n      console.warn(msg);\n      break;\n\n    default:\n      // Set property as long as possible.\n      if (value && !isNS && (name in elem) && (name !== 'type')) {\n        try {\n          elem[name] = value ? value : void 0;\n        } catch(e) {\n          msg = failMsg(elem, name);\n          console.warn(msg);\n        }\n      }\n\n      // Set to property as a fall back.\n      else {\n        isNS = isNS && !!(name.match(xlinkRe));\n        if (value && isNS) {\n          elem.setAttributeNS(XLINK_NS, name, value);\n        } else if (!value && isNS) {\n          elem.removeAttributeNS(XLINK_NS, name);\n        } else if (value) {\n          elem.setAttribute(name, value);\n        } else {\n          elem.removeAttribute(name);\n        }\n      }\n    }\n}\n\n/**\n * Empty an element's children.\n * Remove from the last child might cause less repaint and reflow.\n * @param {Element} elem\n */\nexport function emptyChildren(elem) {\n  if (elem && elem.childNodes && elem.childNodes.length) {\n    let fc = elem.firstChild, lc = elem.lastChild;\n\n    while(fc !== lc) {\n      remove(elem, lc);\n      lc = elem.lastChild;\n    }\n    remove(elem, fc);\n  }\n}\n\n\nfunction failMsg(elem, attr) {\n  let selector = elem.tagName;\n\n  selector = elem.id\n    ? `${selector}#${elem.id}`\n    : selector;\n  selector = elem.className\n    ? `${selector}.${elem.className.join('.')}`\n    : selector;\n  \n    return `Failed to set \"${attr}\" on element \"${selector}\".`\n}","import VNode from './vnode';\nimport { modules } from './module-manager';\nimport { \n  setAttribute,\n  insertBefore,\n  create,\n  remove,\n  append,\n  emptyChildren } from \"./dom-manager\";\n\nexport default patch;\n\n\n/**\n * @param {Element|Text} domRoot \n * @param {VNode} vRoot \n */\nfunction patch(domRoot, vRoot) {\n  if (domRoot instanceof Element || domRoot instanceof Text) {\n    domRoot = patchElement(domRoot, vRoot);\n  }\n  return domRoot;\n}\n\n\n/**\n * Patch a DOM node with a vnode.\n * @param {Element|Text} element \n * @param {VNode} vnode \n * @param {Boolean} same If 2 nodes are already checked by `isSameNode`, it should be set true.\n */\nfunction patchElement(element, vnode, same) {\n  if (vnode == null || typeof vnode === 'boolean')\n    vnode = '';\n\n  // 1. both text nodes.\n  if ((element.nodeType === 3) && (typeof vnode === 'string')) {\n    const oldText = element.textContent || element.nodeValue;\n    if (oldText !== vnode)\n      element.textContent = vnode;\n  }\n  \n  // 2. are the same node.\n  else if (same || isSameNode(element, vnode)) {\n    patchAttrs(element, vnode.attrs);\n    patchChildren(element, vnode);\n    for (const name in vnode.modAttrs) {\n      modules[name].updating(vnode.modAttrs[name]);\n    }\n  }\n\n  // 3. not the same node.\n  else {\n    let node = create(vnode);\n    // replace the `element` with `node`.\n    element = remove(element.parentNode, element, node);\n  }\n\n  return element;\n}\n\n/**\n * See if 2 nodes are the same.\n * @param {Element|Text} element \n * @param {VNode} vnode \n */\nfunction isSameNode(element, vnode) {\n  return element.key === vnode.key && element.tagName === vnode.tagName;\n}\n\n/**\n * Patch 2 same nodes.\n * @param {Element} element \n * @param {VNode} vnode \n */\nfunction patchAttrs(element, vnode) {\n  let attrs = vnode.attrs,\n      oldAttrs = element.__attrs__;\n\n  // Just ensure it is right if `element` was created by a vnode.\n  if (oldAttrs == null) {\n    oldAttrs = element.__attrs__ = oldAttrs == null ? {} : oldAttrs;\n    for (let a = element.attributes, i = a.length; i--; ) {\n      oldAttrs[a[i].name] = a[i].value;\n    }\n  }\n\n  // remove attributes not on vnode.\n  for(const name in oldAttrs) {\n    if (oldAttrs[name] && !(attrs && attrs[name])) {\n      setAttribute(element, name, (oldAttrs[name] = void 0));\n    }\n  }\n\n  // add new & update attributes.\n  for (const name in attrs) {\n    if (!(name in oldAttrs) || attrs[name] !== (\n      name === 'value' || name === 'checked' ? element[name] : old[name])\n    ) {\n      setAttribute(element, name, (oldAttrs[name] = attrs[name]));\n    }\n  }\n}\n\n/**\n * Patch an element's children\n * @param {Element} element \n * @param {VNode} vnode \n */\nfunction patchChildren(element, vnode) {\n  const oldChildren = element.childNodes,\n        vChildren = vnode.children,\n        oldLen = oldChildren.length,\n        vLen = vChildren.length;\n  \n  // nothing to patch.\n  if (vLen === 0 && oldLen === 0) {\n    return;\n  }\n\n  // Special case: if vnode contains only 1 child.\n  else if (vLen === 1) {\n    let ch = vChildren[0],\n        elemToMove;\n\n    if (oldLen === 1 && isSameNode(oldChildren[0], ch)) {\n      patchElement(oldChildren[0], ch, true);\n    }\n\n    else {\n      // Try to find a child node that match.\n      for (let i = 1; i < oldLen; i++) {\n        if (isSameNode(oldChildren[i], ch)) {\n          patchElement(oldChildren[i], ch, true);\n\n          elemToMove = oldChildren[i];\n          break;\n        }\n      }\n\n      // If it wasn't found, create one from the vnode.\n      if (elemToMove === void 0) {\n        elemToMove = create(ch);\n      }\n      emptyChildren(element);\n      element.appendChild(elemToMove);\n    }\n  }\n\n  // case 1: both have children.\n  else if (oldLen !== 0 && vLen > 1) {\n    let keyedChildren,\n        vStart = 0,\n        vEnd = vLen - 1,\n\n        oldStartCh = element.firstChild,\n        oldEndCh = element.lastChild,\n\n        vStartCh = vChildren[vStart],\n        vEndCh = vChildren[vEnd],\n\n        elemToMove;\n\n    while(vStart <= vEnd && oldStartCh !== oldEndCh) {\n      while(vStart <= vEnd && oldStartCh !== oldEndCh && \n        oldStartCh && vStartCh && isSameNode(oldStartCh, vStartCh)\n      ) {\n        patchElement(oldStartCh, vStartCh, true);\n\n        oldStartCh = oldStartCh.nextSibling;\n        vStartCh = vChildren[++vStart];\n      }\n\n      while(vStart <= vEnd && oldStartCh !== oldEndCh && \n        oldEndCh && vEndCh && isSameNode(oldEndCh, vEndCh)\n      ) {\n        patchElement(oldEndCh, vEndCh, true);\n\n        oldEndCh = oldEndCh.previousSibling;\n        vEndCh = vChildren[--vEnd];\n      }\n\n      // in case there is no reordering, but just some insertions or removals.\n      if (oldStartCh === oldEndCh || vStart >= vEnd)  break;\n\n      // Reorder corner case 1.\n      if (isSameNode(oldStartCh, vEndCh)) {\n        patchElement(oldStartCh, vEndCh, true);\n        elemToMove = oldStartCh;\n        oldStartCh = oldStartCh.nextSibling;\n        // place it right behind oldEndCh.\n        insertBefore(element, elemToMove, oldEndCh.nextSibling);\n\n        vEndCh = vChildren[--vEnd];\n      }\n\n      // Reorder corner case 2.\n      else if (isSameNode(oldEndCh, vStartCh)) {\n        patchElement(oldEndCh, vStartCh, true);\n        elemToMove = oldEndCh;\n        oldEndCh = oldEndCh.previousSibling;\n        // place it right in front of oldStartCh.\n        insertBefore(element, elemToMove, oldStartCh);\n\n        vStartCh = vChildren[++vStart];\n      }\n\n      // insert or reorder.\n      else {\n        // try to find element in old list.\n        if (keyedChildren == null) {\n          keyedChildren = createKeyMap(oldChildren, oldStartCh, oldEndCh);\n        }\n        \n        elemToMove = keyedChildren[vStartCh.key];\n\n        // not found. Create a new child.\n        if (elemToMove == null) {\n          elemToMove = create(vStartCh);\n          // place it right in front of oldStartCh\n          insertBefore(element, elemToMove, oldStartCh);\n        }\n        // found. Move it to its place.\n        else {\n          patchElement(elemToMove, startChild);\n          keyedChildren[elemToMove.key] = void 0;\n          // place it right in front of oldStartCh\n          insertBefore(element, elemToMove, oldStartCh);\n        }\n        vStartCh = vChildren[++vStart];\n      }\n    }\n\n    // NOTE: The outer if might be unnecessary.\n    // if oldStartCh is ahead of oldEndCh or is oldEndCh\n    if (vStart <= vEnd || oldStartCh !== oldEndCh || oldStartCh === oldEndCh) {\n      if (oldStartCh) {\n\n        // oldStartCh is ahead of oldEndCh, which means\n        // there are children to be removed.\n        while(oldStartCh !== oldEndCh) {\n          elemToMove = oldStartCh;\n          oldStartCh = oldStartCh.nextSibling;\n          remove(element, elemToMove);\n        }\n\n        if (isSameNode(oldEndCh, vChildren[vEnd])) {\n          patchElement(oldEndCh, vChildren[vEnd], true);\n          if (vStart === vEnd) {\n            return;\n          }\n          vEnd--;\n        }\n\n        else {\n          elemToMove = oldEndCh;\n          oldEndCh = oldEndCh.nextSibling;\n          remove(element, elemToMove);\n        }\n\n        // append new children if there's any.\n        for (let i = vStart; i <= vEnd; i++) {\n          insertBefore(element, create(vChildren[i]), oldEndCh);\n        }\n      }\n    }\n  }\n\n  // case 2: remove all DOM children.\n  else if (oldLen !== 0) {\n    emptyChildren(element);\n  }\n\n  // case 3: insert new DOM children.\n  else if (vLen !== 0) {\n    let newCh;\n\n    for (let i = 0, newCh = vChildren[0]; i < vLen; i++) {\n      element.appendChild(create(newCh));\n    }\n  }\n}\n\n/**\n * Create a map of keyed children.\n * @param {NodeList} children\n * @param {Node} start the node to start from.\n * @param {Node} end  the node to end with\n * @returns { {key: Node} } a map with key equals key, value equals a node associated with this key.\n */\nfunction createKeyMap(children, start, end) {\n  const keyedChildren = {};\n\n  if (start === end && start.key) {\n    keyedChildren[String(start.key)] = start;\n  }\n\n  while(start !== end) {\n    if (start.key != null) {\n      keyedChildren[String(start.key)] = start;\n    }\n    start = start.nextSibling;\n  }\n\n  if (start === end && start.key) {\n    keyedChildren[String(start.key)] = start;\n  }\n\n  return keyedChildren;\n}"],"names":["isArray","obj","Object","prototype","toString","call","svgRe","xlinkRe","SVG_NS","XLINK_NS","addEventListeners","elem","events","handler","params","value","name","shift","warn","__listeners__","addEventListener","proxyEvents","ev","listeners","currentTarget","type","updateInlineStyle","style","oldStyle","__style__","cssText","i","element","modules","VNode","tagName","attrs","children","ns","namespace","test","toUpperCase","modAttrs","key","addNS","vnode","len","length","child","this","classIdSpliter","stack","insertBefore","parentNode","node","domNode","remove","res","replaceChild","removeChild","create","document","createTextNode","createElementNS","createElement","__attrs__","forEach","childElement","appendChild","creating","setAttribute","msg","isNS","__key__","failMsg","e","match","setAttributeNS","removeAttributeNS","removeAttribute","emptyChildren","childNodes","fc","firstChild","lc","lastChild","attr","selector","id","className","join","patchElement","same","nodeType","textContent","nodeValue","isSameNode","oldAttrs","a","attributes","old","oldChildren","vChildren","oldLen","vLen","elemToMove","ch","keyedChildren","vStart","vEnd","oldStartCh","oldEndCh","vStartCh","vEndCh","nextSibling","previousSibling","createKeyMap","startChild","newCh","updating","start","end","String","Array","slice","arguments","tagInfo","lastPrimitive","push","idxKey","pop","result","split","part","substr","parseSelector","Error","domRoot","vRoot","Element","Text"],"mappings":"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"}