{"version":3,"file":"amber-dom.min.js","sources":["../src/util.js","../src/vnode.js","../src/h.js","../src/domManager.js","../src/patch.js","../src/amber-dom.js"],"sourcesContent":["export function isArray (obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\nexport function isEmpty(obj) {\n  return Object.keys(obj|| {}).length === 0;\n}\n\nexport const eventHookRe = /^ev\\-([a-z]+)/;\nexport const svgRe = /(svg|SVG)/;\nexport const xlinkRe = /^xlink:(.*)$/;\nexport const SVG_NS = 'http://www.w3.org/2000/svg';\nexport const XLINK_NS = 'http://www.w3.org/1999/xlink';\n","import { eventHookRe, svgRe, SVG_NS } from './util';\nexport default VNode;\n\n/**\n * Add namespace for `vnode` and recursively add it to its children.\n * @param {VNode} vnode A vnode.\n * @param {String} ns A namespace.\n */\nfunction addNS(vnode, ns) {\n  const children = vnode.children;\n  vnode.ns = ns;\n\n  for (let i = 0, len = children.length; i < len; i++) {\n    let child = children[i];\n\n    if (child instanceof VNode) {\n      addNS(child, ns);\n    }\n  }\n}\n\nclass VNode {\n  /**\n   * @param {String} tagName a tag name. Must be specified.\n   * @param {Object|null} props can be an empty object.\n   * @param {Array|null} children can be an empty array.\n   */\n  constructor(tagName, props, children) {\n    this.tagName = tagName.toUpperCase();\n    this.props = props || {};\n    this.children = children || [];\n    this.key = props && props.key;\n    \n    let ns = (props && props.namespace) ||\n      (svgRe.test(tagName) ? SVG_NS : void 0);\n\n    if (ns) {\n      addNS(this, ns);\n    }\n  }\n}","import VNode from './vnode';\nimport { isArray } from './util';\nexport default h;\n\n\nconst classIdSpliter = /([\\.#]?[^\\s#.]+)/;\nconst spaceStriper = /^\\s*|\\s*$/;\nconst propSpliter = /\\s*=\\s*/;\nconst stack = [];   // internal stack for parsing children.\n\n/**\n * A selector might contain a tag name followed by some CSS selector.\n * This function was stripped and modiffied from hyperscript's  parseClass.\n * @see https://github.com/hyperhype/hyperscript/blob/master/index.js\n * @param {String} selector \n */\nfunction parseSelector(selector) {\n  const parts = selector.split(classIdSpliter);\n  const result = {};\n\n  parts.forEach(part => {\n    if (part === '')  return;\n\n    if (!result.tagName) {\n      result.tagName = part;\n    } else if (part[0] === '.') {\n      (result.className || (result.className = [])).push(part.substr(1));\n    } else if (part[0] === '#') {\n      result.id = part.substr(1);\n    }\n  });\n\n  result.className && result.className.join(' ');\n  return result;\n}\n\n/**\n * Original propto: h(selector, props, ...children).\n * \n * Found a more elegant way to handle children. Referred to Hyperapp's `h` function, which is dead simple. \n * @see https://github.com/hyperapp/hyperapp/blob/master/src/index.js\n * @param {String|Function} selector a built-in tag name or custom function that returns an object created by h.\n * @param {Object} props optional. any style, event listeners, and className should be put here.\n * @param {*} rest optional children. Can be nested.\n */\nfunction h(selector, props) {\n  // Case 1: `selector` is a function.\n  if (typeof selector === 'function') {\n    // use `new` in case it is a class.\n    return new selector(Array.prototype.slice.call(arguments, 1));\n  }\n\n  let tagInfo, children = [], child;\n\n  (props || (props = {}))\n\n  // collect children\n  for (let i = arguments.length; i-- > 2; ) {\n    stack.push(arguments[i]);\n  }\n\n  // if props is any of these below, it must be a child.\n  if ((props instanceof VNode) ||\n    (typeof props === 'string') ||\n    (typeof props === 'number') ||\n    (typeof props === 'boolean') ||\n    (isArray(props))\n  ) {\n    stack.push(props);\n    props = {};\n  }\n\n  // handle nested children if there's any.\n  while (stack.length) {\n    if ((child = stack.pop()) && child.pop !== void 0) {\n      for (let i = child.length; i--;)  stack.push(child[i]);\n    }\n\n    else {\n      child = child == null ? '' : child;\n      child = typeof child === 'boolean' ? '' : child;\n      child = typeof child === 'number' ? String(child) : child;\n\n      children.push(child);\n    }\n  }\n\n  // Case 2: `selector` is 'text'. \n  if (selector === 'text') {\n    return children.length === 0\n      ? ''\n      : children.join(' ');\n  }\n\n  // Case 3: `selector` is a selector.\n  else if (typeof selector === 'string') {\n    if (props.className && isArray(props.className)) {\n      props.className = props.className.join(' ');\n    }\n\n    tagInfo = parseSelector(selector);\n    if (tagInfo.className) {\n      props.className = props.className\n        ? props.className + ' ' + tagInfo.className\n        : tagInfo.className;\n    }\n\n    if (tagInfo.id) {\n      props.id = props.id ? props.id : tagInfo.id;\n    }\n\n    return new VNode(tagInfo.tagName, props, children);\n  }\n  \n  else {\n    throw new Error(`Unrecognized selector: ${selector}.`)\n  }\n}","import { eventHookRe, XLINK_NS, xlinkRe } from \"./util\";\nimport VNode from './vnode';\n\nexport default domManager;\n\n// dom mangager. Used internally.\nconst domManager = {\n  append,\n  insertBefore,\n  remove,\n  replace,\n  nextSibling,\n  create,\n  setAttribute\n};\n\n/**\n * @param {Element} parentNode \n * @param {Element} node \n */\nexport function append(parentNode, node) {\n  parentNode.appendChild(node);\n}\n\n/**\n * @param {Element} parentNode\n * @param {Element} node \n * @param {Element} domNode the reference node.\n */\nexport function insertBefore(parentNode, node, domNode) {\n  parentNode.insertBefore(node, domNode);\n}\n\n/**\n * @param {Element} parentNode \n * @param {Element} domNode \n * @param {Element} node \n */\nexport function replace(parentNode, node, domNode) {\n  if (node.parentNode === parentNode)\n    parentNode.replaceChild(node, domNode);\n  return domNode;\n}\n\n/**\n * Remove a child on a node if it exists.\n * @param {Element} parentNode \n * @param {Element} node \n */\nexport function remove(parentNode, node) {\n  if (node.parentNode === parentNode)\n    parentNode.removeChild(node);\n  return node;\n}\n\n/**\n * Get next sibling of node.\n * @param {Element} node\n */\nexport function nextSibling(node) {\n  if (node instanceof Element) {\n    return node.nextSibling;\n  }\n  return null;\n}\n\n/**\n * Create a DOM node represented by `vnode`\n * @param {String|Number|VNode} vnode \n */\nexport function create(vnode) {\n  // create a text node if it is a string or a number.\n  if (typeof vnode === 'string' || typeof vnode === 'number')\n    return document.createTextNode(vnode);\n\n  const tagName = vnode.tagName;\n  const props = vnode.props;\n  const children = vnode.children;\n  const ns = vnode.ns;\n  const element = ns\n    ? document.createElementNS(ns, tagName)\n    : document.createElement(tagName);\n\n  // for next diff.\n  element.$props = props;\n  for (const propName in props) {\n    const event = propName.match(eventHookRe);\n    if (event) {\n      const handler = typeof props[propName] === 'function'\n        ? props[propName]\n        : new Error(`Handler to ${event[1]} is not a function`);\n\n      if (handler instanceof Error) {\n        console.warn(`Failed to add listener for ${event[1]}: ${handler.message}`);\n      }\n\n      // for next diff.\n      (element._listeners || (element._listeners = {}))[event[1]] = handler;\n      element.addEventListener(event[1], handler, false);\n    }\n\n    else {\n      setAttribute(element, propName, props[propName], !!ns);\n    }\n  }\n\n  children.forEach(child => {\n    let childElement;\n\n    if (child instanceof VNode || typeof child === 'string') {\n      childElement = create(child);\n    }\n\n    // TODO: add thunk.\n\n    else {\n      console.warn(`Unrecognizable node: ${child}`);\n    }\n\n    element.appendChild(childElement);\n  });\n\n  if (vnode.created) {\n    vnode.created(element);\n  }\n\n  return element;\n}\n\n/**\n * Set attribute/property on an element.\n * @param {Element} element \n * @param {String} attrName \n * @param {String} value \n */\nexport function setAttribute(element, attrName, value, isNameSpaced) {\n  let ns, oldValue;\n\n  attrName = attrName === 'className' ? 'class' : attrName;\n\n  switch(attrName) {\n  case 'key':\n    element.key = value;\n    break;\n  \n  case 'style':   /** if style is an object, it'll always be patched. */\n    oldValue = element.$style;\n\n    if (!value || typeof value === 'string' || typeof oldValue === 'string') {\n      // if `value` is an object, it will be reset below.\n      element.style.cssText = value || '';\n    }\n    \n    if (value && typeof value === 'object') {\n      // set every old style field to empty.\n      if (typeof oldValue !== 'string') {\n        for (let i in oldValue) {\n          if (!(i in value))\n            element.style[i] = '';\n        }\n      }\n      \n      for (let i in value) {\n        element.style[i] = value[i];\n      }\n    }\n\n    // for next diff.\n    element.$style = value ? value : '';\n\n    break;\n  \n  case 'class':\n    element.className = value || '';\n    break;\n\n  case 'children':\n    console.warn(`Failed to set \"children\" on element ${element.tagName}.`);\n    break;\n\n  case 'innerHTML':\n    console.warn(`Failed to set \"innerHTML\" on a \"${element.tagName.toLocaleLowerCase()}\".`);\n    break;\n\n  default:\n    if (!isNameSpaced && (attrName in element) && (attrName !== 'type')) {\n      // set it as a property.\n      try {\n        element[attrName] = value ? value : '';\n      } catch(e) {\n        console.warn(`Failed to set attribute: ${attrName} on element \"${element.id ? element.tagName + element.id : element.tagName }\"`)\n      }\n\n      if (value == null) {\n        element.removeAttribute(attrName);\n      }\n    }\n\n    else {\n      ns = isNameSpaced && !!(attrName = (attrName.match(xlinkRe))[1]);\n      // set it as an attribute.\n      if (value && ns) {\n        element.setAttributeNS(XLINK_NS, attrName, value);\n      } else if (!value && ns) {\n        element.removeAttributeNS(XLINK_NS, attrName);\n      } else if (value) {\n        element.setAttribute(attrName, value);\n      } else {\n        element.removeAttribute(attrName);\n      }\n    }\n  }\n}\n","import VNode from './vnode';\nimport { eventHookRe, isEmpty } from './util';\nimport { \n  setAttribute,\n  insertBefore,\n  replace,\n  create,\n  remove } from \"./domManager\";\n\nexport default patch;\n\n\n/**\n * @param {Element|Text} domRoot \n * @param {VNode} vRoot \n */\nfunction patch(domRoot, vRoot) {\n  if (domRoot instanceof Element || domRoot instanceof Text)\n    patchElement(domRoot, vRoot);\n}\n\n\n/**\n * Patch a DOM node with a vnode.\n * @param {Element|Text} element \n * @param {VNode} vnode \n */\nfunction patchElement(element, vnode) {\n  if (vnode == null || typeof vnode === 'boolean')\n    vnode = '';\n\n  // 1. both text nodes.\n  if (\n    (element.nodeType === 3) &&\n    (typeof vnode === 'string' || typeof vnode === 'number')\n  ) {\n    const oldText = element.textContent || element.nodeValue;\n    if (oldText !== vnode)\n      element.textContent = vnode;\n  }\n\n  // 2. are the same node.\n  else if (isSameNode(element, vnode)) {\n    patchProps(element, vnode);\n    patchChildren(element, vnode);\n  }\n  \n  // 3. not the same node.\n  else {\n    replace(element.parentNode, create(vnode), element);\n  }\n}\n\n/**\n * See if 2 nodes are of the same type & have the same key.\n * Text nodes will do find because it will be patched by `patchedElement` eventually.\n * @param {Element|Text} element \n * @param {VNode} vnode \n */\nfunction isSameNode(element, vnode) {\n  return element.key === vnode.key && element.tagName === vnode.tagName;\n}\n\n/**\n * Patch 2 nodes' props/attributes.\n * @param {Element} element \n * @param {VNode} vnode \n */\nfunction patchProps(element, vnode) {\n  const attrs = vnode.props;\n  let old = element.$props;\n  const isSvg = !!element.ns;\n\n  // if this dom node wasn't diffed before, or wasn't created\n  // by `create`, pull out its attributes and patch them.\n  if (old == null || isEmpty(old)) {\n    old = element.$props = old == null ? {}: old;\n    for (let a = element.attributes, i = a.length; i--; ) {\n      old[a[i].name] = a[i].value;\n    }\n  }\n\n  // remove attributes not on vnode.\n  for(const name in old) {\n    if (old[name] && !(attrs && attrs[name])) {\n      setAttribute(element, name, (old[name] = void 0), isSvg);\n    }\n  }\n\n  // add new & update attributes.\n  // Don't worry about style object,\n  // because `setAttribute` will deal with it.\n  for (const name in attrs) {\n    if (!(name in old) || attrs[name] !== (\n      name === 'value' || name === 'checked' ? element[name] : old[name])\n    ) {\n      setAttribute(element, name, attrs[name], isSvg);\n    }\n  }\n}\n\n/**\n * Patch an element's children\n * @param {Element} element \n * @param {VNode} vnode \n */\nfunction patchChildren(element, vnode) {\n  const oldChildren = element.childNodes,\n        vChildren = vnode.children,\n        oldLen = oldChildren.length,\n        vLen = vChildren.length;\n  \n  // nothing to patch.\n  if (vLen === 0 && oldLen === 0) {\n    return;\n  }\n\n  // case 1: both have children.\n  else if (oldLen !== 0 && vLen !== 0) {\n    let keyedChildren,\n        vStart = 0,\n        vEnd = vLen - 1,\n\n        oldStartCh = element.firstChild,\n        oldEndCh = element.lastChild,\n\n        vStartCh = vChildren[vStart],\n        vEndCh = vChildren[vEnd],\n\n        elemToMove;\n\n    while(vStart <= vEnd && oldStartCh !== oldEndCh) {\n      while(isSameNode(oldStartCh, vStartCh)) {\n        patchElement(oldStartCh, vStartCh);\n\n        oldStartCh = oldStartCh.nextSibling;\n        vStartCh = vChildren[++vStart];\n      }\n\n      while(isSameNode(oldEndCh, vEndCh)) {\n        patchElement(oldEndCh, vEndCh);\n\n        oldEndCh = oldEndCh.previousSibling;\n        vEndCh = vChildren[--vEnd];\n      }\n\n      // in case there is no reordering, but just some insertions or removals.\n      if (oldStartCh === oldEndCh || vStart === vEnd)  break;\n\n      // move corner case 1.\n      if (isSameNode(oldStartCh, vEndCh)) {\n        patchElement(oldStartCh, vEndCh);\n        elemToMove = oldStartCh;\n        oldStartCh = oldStartCh.nextSibling;\n        // place it right behind oldEndCh.\n        insertBefore(element, elemToMove, oldEndCh.nextSibling);\n\n        vEndCh = vChildren[--vEnd];\n      }\n\n      // move corner case 2.\n      else if (isSameNode(oldEndCh, vStartCh)) {\n        patchElement(oldEndCh, vStartCh);\n        elemToMove = oldEndCh;\n        oldEndCh = oldEndCh.previousSibling;\n        // place it right in front of oldStartCh.\n        insertBefore(element, elemToMove, oldStartCh.previousSibling);\n\n        vStartCh = vChildren[++vStart];\n      }\n\n      // insert or move.\n      else {\n        // try to find element in old list.\n        if (keyedChildren == null) {\n          keyedChildren = createKeyMap(oldChildren, oldStartCh, oldEndCh);\n        }\n        \n        elemToMove = keyedChildren[vStartCh.key];\n\n        // create a new element\n        if (elemToMove == null) {\n          elemToMove = create(vStartCh);\n          // place it right in front of oldStartCh\n          insertBefore(element, elemToMove, oldStartCh);\n        }\n        // the element is in the map.\n        else {\n          elemToMove = oldChildren[idxInOld];\n          patchElement(elemToMove, startChild);\n          keyedChildren[elemToMove.key] = void 0;\n          // place it right in front of oldStartCh\n          insertBefore(element, elemToMove, oldStartCh);\n        }\n        vStartCh = vChildren[++vStart];\n      }\n    }\n\n    if (vStart <= vEnd || oldStartCh !== oldEndCh) {\n      // remove children.\n      if (oldStartCh !== oldEndCh) {\n        while(oldStartCh !== oldEndCh) {\n          remove(element, oldStartCh);\n          oldStartCh = oldStartCh.nextSibling;\n        }\n        remove(element, oldStartCh);\n      }\n\n      // insert children.\n      else {\n        for (let i = vStart; i <= vEnd; i++) {\n          insertBefore(element, create(vChildren[i]), oldEndCh);\n        }\n      }\n    }\n  }\n\n  // case 2: remove all DOM children.\n  else if (oldLen !== 0) {\n    // To reduce reflow.\n    let oldCh = oldChildren.lastChild;\n    let fc = oldChildren.firstChild;\n\n    while(oldCh !== fc) {\n      remove(element, oldCh);\n      oldCh = oldCh.previousSibling;\n    }\n\n    if (oldCh === fc) {\n      remove(element, oldCh);\n    }\n  }\n\n  // case 3: insert new DOM children.\n  else if (vLen !== 0) {\n    let newCh;\n\n    for (let i = 0, newCh = vChildren[0]; i < vLen; i++) {\n      element.appendChild(create(newCh));\n    }\n  }\n}\n\n/**\n * Create a map of keyed children.\n * @param {NodeList} children\n * @param {Node} start the node to start from.\n * @param {Node} end  the node to end with\n * @returns { {key: Node} } a map with key equals key, value equals a node associated with this key.\n */\nfunction createKeyMap(children, start, end) {\n  const keyedChildren = {};\n\n  if (start === end && start.key) {\n    keyedChildren[String(start.key)] = start;\n  }\n\n  while(start !== end) {\n    if (start.key != null) {\n      keyedChildren[String(start.key)] = start;\n    }\n    start = start.nextSibling;\n  }\n\n  if (start === end && start.key) {\n    keyedChildren[String(start.key)] = start;\n  }\n\n  return keyedChildren;\n}","import h from './h';\nimport patch from './patch';\nimport VNode from './vnode';\nimport { create as createElement } from './domManager';\n\nconst amberdom = {\n  h,\n  patch,\n  VNode,\n  createElement\n};\n\nexport default amberdom;\n\nexport { default as h } from './h';\nexport { default as patch } from './patch';\nexport { default as VNode } from './vnode';\nexport { create as createElement } from './domManager';"],"names":["isArray","obj","Object","prototype","toString","call","eventHookRe","svgRe","xlinkRe","SVG_NS","XLINK_NS","VNode","tagName","props","children","toUpperCase","key","ns","namespace","test","addNS","vnode","i","len","length","child","this","classIdSpliter","stack","h","selector","Array","slice","arguments","tagInfo","push","pop","String","join","className","result","split","forEach","part","substr","id","parseSelector","Error","insertBefore","parentNode","node","domNode","remove","removeChild","create","document","createTextNode","element","createElementNS","createElement","$props","propName","event","match","handler","warn","message","_listeners","addEventListener","childElement","appendChild","created","setAttribute","attrName","value","isNameSpaced","oldValue","$style","style","cssText","toLocaleLowerCase","e","removeAttribute","setAttributeNS","removeAttributeNS","patch","domRoot","vRoot","Element","Text","patchElement","nodeType","isSameNode","attrs","old","isSvg","keys","a","attributes","name","oldChildren","childNodes","vChildren","oldLen","vLen","keyedChildren","elemToMove","vStart","vEnd","oldStartCh","firstChild","oldEndCh","lastChild","vStartCh","vEndCh","nextSibling","previousSibling","createKeyMap","idxInOld","startChild","oldCh","fc","newCh","replaceChild","textContent","nodeValue","start","end","amberdom"],"mappings":"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"}