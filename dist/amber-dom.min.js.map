{"version":3,"file":"amber-dom.min.js","sources":["../src/util.js","../src/vnode.js","../src/h.js","../src/domManager.js","../src/patch.js","../src/amber-dom.js"],"sourcesContent":["export function isArray (obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\nexport function isEmpty(obj) {\n  return Object.keys(obj|| {}).length === 0;\n}\n\nexport const eventHookRe = /^ev\\-([a-z]+)/;\nexport const svgRe = /(svg|SVG)/;\nexport const xlinkRe = /^xlink:(.*)$/;\nexport const SVG_NS = 'http://www.w3.org/2000/svg';\nexport const XLINK_NS = 'http://www.w3.org/1999/xlink';\n","import { eventHookRe, svgRe, SVG_NS } from './util';\nexport default VNode;\n\n/**\n * Add namespace for `vnode` and recursively add it to its children.\n * @param {VNode} vnode A vnode.\n * @param {String} ns A namespace.\n */\nfunction addNS(vnode, ns) {\n  const children = vnode.children;\n  vnode.ns = ns;\n\n  for (let i = 0, len = children.length; i < len; i++) {\n    let child = children[i];\n\n    if (child instanceof VNode) {\n      addNS(child, ns);\n    }\n  }\n}\n\n/**\n * Ensure all children have keys. If no key is provided,\n * use index instead.\n * @param {Array} children \n */\nfunction addChildKeys(children) {\n  let ch;\n\n  for (let i = 0, len = children.length; i < len; i++) {\n    ch = children[i];\n\n    if (ch instanceof VNode) {\n      ch.key = ch.props.key = ch.props.key != null\n        ? ch.props.key : i;\n    }\n  }\n}\n\nclass VNode {\n  /**\n   * @param {String} tagName a tag name. Must be specified.\n   * @param {Object|null} props can be an empty object.\n   * @param {Array|null} children can be an empty array.\n   */\n  constructor(tagName, props, children) {\n    this.tagName = tagName.toUpperCase();\n    this.props = props || {};\n    this.children = children || [];\n    this.key = props && props.key;\n    \n    let ns = (props && props.namespace) ||\n      (svgRe.test(tagName) ? SVG_NS : void 0);\n\n    if (ns) {\n      addNS(this, ns);\n    }\n\n    addChildKeys(this.children);\n\n    // deal with hooks.\n    if (props.hooks) {\n      for (const name in props.hooks) {\n        this[name] = props.hooks[name];\n      }\n      delete props.hooks;\n    }\n  }\n}","import VNode from './vnode';\nimport { isArray } from './util';\nexport default h;\n\n\nconst classIdSpliter = /([\\.#]?[^\\s#.]+)/;\nconst spaceStriper = /^\\s*|\\s*$/;\nconst propSpliter = /\\s*=\\s*/;\nconst stack = [];   // internal stack for parsing children.\n\n/**\n * A selector might contain a tag name followed by some CSS selector.\n * This function was stripped and modiffied from hyperscript's  parseClass.\n * @see https://github.com/hyperhype/hyperscript/blob/master/index.js\n * @param {String} selector \n */\nfunction parseSelector(selector) {\n  const parts = selector.split(classIdSpliter);\n  const result = {};\n\n  parts.forEach(part => {\n    if (part === '')  return;\n\n    if (!result.tagName) {\n      result.tagName = part;\n    } else if (part[0] === '.') {\n      (result.className || (result.className = [])).push(part.substr(1));\n    } else if (part[0] === '#') {\n      result.id = part.substr(1);\n    }\n  });\n\n  result.className && (result.className = result.className.join(' '));\n  return result;\n}\n\n/**\n * Original propto: h(selector, props, ...children).\n * \n * Found a more elegant way to handle children. Referred to Hyperapp's `h` function, which is dead simple. \n * @see https://github.com/hyperapp/hyperapp/blob/master/src/index.js\n * @param {String|Function} selector a built-in tag name or custom function that returns an object created by h.\n * @param {Object} props optional. any style, event listeners, and className should be put here.\n * @param {*} rest optional children. Can be nested.\n */\nfunction h(selector, props) {\n  // Case 1: `selector` is a function.\n  if (typeof selector === 'function') {\n    // use `new` in case it is a class.\n    return new selector(...Array.prototype.slice.call(arguments, 1));\n  }\n\n  let tagInfo, children = [], child;\n\n  (props || (props = {}))\n\n  // collect children\n  for (let i = arguments.length; i-- > 2; ) {\n    stack.push(arguments[i]);\n  }\n\n  // if props is any of these below, it must be a child.\n  if ((props instanceof VNode) ||\n    (typeof props === 'string') ||\n    (typeof props === 'number') ||\n    (typeof props === 'boolean') ||\n    (isArray(props))\n  ) {\n    stack.push(props);\n    props = {};\n  }\n\n  // handle nested children if there's any.\n  while (stack.length) {\n    if ((child = stack.pop()) && child.pop !== void 0) {\n      for (let i = child.length; i--;)  stack.push(child[i]);\n    }\n\n    else {\n      child = child == null ? '' : child;\n      child = typeof child === 'boolean' ? '' : child;\n      child = typeof child === 'number' ? String(child) : child;\n\n      children.push(child);\n    }\n  }\n\n  // Case 2: `selector` is 'text'. \n  if (selector === 'text') {\n    return children.length === 0\n      ? ''\n      : children.join(' ');\n  }\n\n  // Case 3: `selector` is a selector.\n  else if (typeof selector === 'string') {\n    if (props.className && isArray(props.className)) {\n      props.className = props.className.join(' ');\n    }\n\n    tagInfo = parseSelector(selector);\n    if (tagInfo.className) {\n      props.className = props.className\n        ? props.className + ' ' + tagInfo.className\n        : tagInfo.className;\n    }\n\n    if (tagInfo.id) {\n      props.id = props.id ? props.id : tagInfo.id;\n    }\n\n    return new VNode(tagInfo.tagName, props, children);\n  }\n  \n  else {\n    throw new Error(`Unrecognized selector: ${selector}.`)\n  }\n}","import { eventHookRe, XLINK_NS, xlinkRe } from \"./util\";\nimport VNode from './vnode';\n\nexport default domManager;\n\n// dom mangager. Used internally.\nconst domManager = {\n  append,\n  insertBefore,\n  remove,\n  replace,\n  nextSibling,\n  create,\n  setAttribute\n};\n\n/**\n * @param {Element} parentNode \n * @param {Element} node \n */\nexport function append(parentNode, node) {\n  parentNode.appendChild(node);\n}\n\n/**\n * @param {Element} parentNode\n * @param {Element} node \n * @param {Element} domNode the reference node.\n */\nexport function insertBefore(parentNode, node, domNode) {\n  parentNode.insertBefore(node, domNode);\n}\n\n/**\n * @param {Element} parentNode \n * @param {Element} domNode \n * @param {Element} node \n */\nexport function replace(parentNode, node, domNode) {\n  if (parentNode && node.parentNode === parentNode)\n    parentNode.replaceChild(node, domNode);\n  return domNode;\n}\n\n/**\n * Remove a child on a node if it exists.\n * @param {Element} parentNode \n * @param {Element} node \n */\nexport function remove(parentNode, node) {\n  if (node.parentNode === parentNode)\n    parentNode.removeChild(node);\n  return node;\n}\n\n/**\n * Get next sibling of node.\n * @param {Element} node\n */\nexport function nextSibling(node) {\n  if (node instanceof Element) {\n    return node.nextSibling;\n  }\n  return null;\n}\n\n/**\n * Create a DOM node represented by `vnode`\n * @param {String|Number|VNode} vnode \n */\nexport function create(vnode) {\n  // create a text node if it is a string or a number.\n  if (typeof vnode === 'string' || typeof vnode === 'number')\n    return document.createTextNode(vnode);\n\n  const tagName = vnode.tagName;\n  const props = vnode.props;\n  const children = vnode.children;\n  const ns = vnode.ns;\n  const element = ns\n    ? document.createElementNS(ns, tagName)\n    : document.createElement(tagName);\n\n  // for next diff.\n  element.$props = props;\n  for (const propName in props) {\n    const event = propName.match(eventHookRe);\n    if (event) {\n      const handler = typeof props[propName] === 'function'\n        ? props[propName]\n        : new Error(`Handler to ${event[1]} is not a function`);\n\n      if (handler instanceof Error) {\n        console.warn(`Failed to add listener for ${event[1]}: ${handler.message}`);\n      }\n\n      // for next diff.\n      (element._listeners || (element._listeners = {}))[event[1]] = handler;\n      element.addEventListener(event[1], handler, false);\n    }\n\n    else {\n      setAttribute(element, propName, props[propName], !!ns);\n    }\n  }\n\n  children.forEach((child, i) => {\n    let childElement;\n\n    if (child instanceof VNode || typeof child === 'string') {\n      childElement = create(child);\n    }\n\n    // TODO: add thunk.\n\n    else {\n      console.warn(`Unrecognizable node: ${child}`);\n    }\n\n    element.appendChild(childElement);\n  });\n\n  if (vnode.created) {\n    vnode.created(element);\n  }\n\n  return element;\n}\n\n/**\n * Set attribute/property on an element.\n * @param {Element} element \n * @param {String} attrName \n * @param {String} value \n */\nexport function setAttribute(element, attrName, value, isNameSpaced) {\n  let ns, oldValue;\n\n  attrName = attrName === 'className' ? 'class' : attrName;\n\n  switch(attrName) {\n  case 'key':\n    element.key = value;\n    break;\n  \n  case 'style':   /** if style is an object, it'll always be patched. */\n    oldValue = element.$style;\n\n    if (!value || typeof value === 'string' || typeof oldValue === 'string') {\n      // if `value` is an object, it will be reset below.\n      element.style.cssText = value || '';\n    }\n    \n    if (value && typeof value === 'object') {\n      // set every old style field to empty.\n      if (typeof oldValue !== 'string') {\n        for (let i in oldValue) {\n          if (!(i in value))\n            element.style[i] = '';\n        }\n      }\n      \n      // you might be wondering why don't I compare the value before setting\n      // it. In fact, no comparison is needed because it won't cause the browser's\n      // repaint or reflow if the new value is the same as old one.\n      for (let i in value) {\n        element.style[i] = value[i];\n      }\n    }\n\n    // for next diff.\n    element.$style = value ? value : '';\n\n    break;\n  \n  case 'class':\n    element.className = value || '';\n    break;\n\n  case 'children':\n    console.warn(`Failed to set \"children\" on element ${element.tagName}.`);\n    break;\n\n  case 'innerHTML':\n    console.warn(`Failed to set \"innerHTML\" on a \"${element.tagName.toLocaleLowerCase()}\".`);\n    break;\n\n  default:\n    if (!isNameSpaced && (attrName in element) && (attrName !== 'type')) {\n      // set it as a property.\n      try {\n        element[attrName] = value ? value : '';\n      } catch(e) {\n        console.warn(`Failed to set attribute: ${attrName} on element \"${element.id ? element.tagName + element.id : element.tagName }\"`)\n      }\n\n      if (value == null) {\n        element.removeAttribute(attrName);\n      }\n    }\n\n    else {\n      ns = isNameSpaced && !!(attrName = (attrName.match(xlinkRe)));\n      // set it as an attribute.\n      if (value && ns) {\n        element.setAttributeNS(XLINK_NS, attrName, value);\n      } else if (!value && ns) {\n        element.removeAttributeNS(XLINK_NS, attrName);\n      } else if (value) {\n        element.setAttribute(attrName, value);\n      } else {\n        element.removeAttribute(attrName);\n      }\n    }\n  }\n}\n\n/**\n * Empty an element's children.\n * @param {Element} element \n */\nexport function emptyChildren(element) {\n  if (element && element.childNodes && element.childNodes.length) {\n    let fc = element.firstChild, lc = element.lastChild;\n\n    while(fc !== lc) {\n      remove(element, lc);\n      lc = element.lastChild;\n    }\n    remove(element, fc);\n  }\n}","import VNode from './vnode';\nimport { eventHookRe, isEmpty } from './util';\nimport { \n  setAttribute,\n  insertBefore,\n  replace,\n  create,\n  remove,\n  append,\n  emptyChildren } from \"./domManager\";\n\nexport default patch;\n\n\n/**\n * @param {Element|Text} domRoot \n * @param {VNode} vRoot \n */\nfunction patch(domRoot, vRoot) {\n  if (domRoot instanceof Element || domRoot instanceof Text) {\n    domRoot = patchElement(domRoot, vRoot);\n  }\n  return domRoot;\n}\n\n\n/**\n * Patch a DOM node with a vnode.\n * @param {Element|Text} element \n * @param {VNode} vnode \n */\nfunction patchElement(element, vnode) {\n  if (vnode == null || typeof vnode === 'boolean')\n    vnode = '';\n\n  // 1. both text nodes.\n  if (\n    (element.nodeType === 3) &&\n    (typeof vnode === 'string' || typeof vnode === 'number')\n  ) {\n    const oldText = element.textContent || element.nodeValue;\n    if (oldText !== vnode)\n      element.textContent = vnode;\n  }\n\n  // 2. are the same node.\n  else if (isSameNode(element, vnode)) {\n    patchProps(element, vnode);\n    patchChildren(element, vnode);\n  }\n  \n  // 3. not the same node.\n  else {\n    let node = create(vnode);\n    replace(element.parentNode, node, element);\n  }\n\n  return element;\n}\n\n/**\n * See if 2 nodes are of the same type & have the same key.\n * Text nodes will do find because it will be patched by `patchedElement` eventually.\n * @param {Element|Text} element \n * @param {VNode} vnode \n */\nfunction isSameNode(element, vnode) {\n  return element.key === vnode.key && element.tagName === vnode.tagName;\n}\n\n/**\n * Patch 2 nodes' props/attributes.\n * @param {Element} element \n * @param {VNode} vnode \n */\nfunction patchProps(element, vnode) {\n  const attrs = vnode.props;\n  let old = element.$props;\n  const isSvg = !!element.ns;\n\n  // if this dom node wasn't diffed before, or wasn't created\n  // by `create`, pull out its attributes and patch them.\n  if (old == null || isEmpty(old)) {\n    old = element.$props = old == null ? {}: old;\n    for (let a = element.attributes, i = a.length; i--; ) {\n      old[a[i].name] = a[i].value;\n    }\n  }\n\n  // remove attributes not on vnode.\n  for(const name in old) {\n    if (old[name] && !(attrs && attrs[name])) {\n      setAttribute(element, name, (old[name] = void 0), isSvg);\n    }\n  }\n\n  // add new & update attributes.\n  // Don't worry about style object,\n  // because `setAttribute` will deal with it.\n  for (const name in attrs) {\n    if (!(name in old) || attrs[name] !== (\n      name === 'value' || name === 'checked' ? element[name] : old[name])\n    ) {\n      setAttribute(element, name, attrs[name], isSvg);\n    }\n  }\n}\n\n/**\n * Patch an element's children\n * @param {Element} element \n * @param {VNode} vnode \n */\nfunction patchChildren(element, vnode) {\n  const oldChildren = element.childNodes,\n        vChildren = vnode.children,\n        oldLen = oldChildren.length,\n        vLen = vChildren.length;\n  \n  // nothing to patch.\n  if (vLen === 0 && oldLen === 0) {\n    return;\n  }\n\n  // Special case: if vnode contains only 1 child.\n  else if (vLen === 1) {\n    let ch = vChildren[0],\n        elemToMove;\n\n    // Try to find a child node that match.\n    for (let i = 0; i < oldLen; i++) {\n      if (isSameNode(oldChildren[i], ch)) {\n        patchElement(oldChildren[i], ch);\n\n        elemToMove = oldChildren[i];\n        break;\n      }\n    }\n    // If it wasn't found, create one from the vnode.\n    if (elemToMove === void 0) {\n      elemToMove = create(ch);\n    }\n    emptyChildren(element);\n    element.appendChild(elemToMove);\n  }\n\n  // case 1: both have children.\n  else if (oldLen !== 0 && vLen > 1) {\n    let keyedChildren,\n        vStart = 0,\n        vEnd = vLen - 1,\n\n        oldStartCh = element.firstChild,\n        oldEndCh = element.lastChild,\n\n        vStartCh = vChildren[vStart],\n        vEndCh = vChildren[vEnd],\n\n        elemToMove;\n\n    while(vStart <= vEnd && oldStartCh !== oldEndCh) {\n      while(vStart <= vEnd && oldStartCh !== oldEndCh && \n        oldStartCh && vStartCh && isSameNode(oldStartCh, vStartCh)\n      ) {\n        patchElement(oldStartCh, vStartCh);\n\n        oldStartCh = oldStartCh.nextSibling;\n        vStartCh = vChildren[++vStart];\n      }\n\n      while(vStart <= vEnd && oldStartCh !== oldEndCh && \n        oldEndCh && vEndCh && isSameNode(oldEndCh, vEndCh)\n      ) {\n        patchElement(oldEndCh, vEndCh);\n\n        oldEndCh = oldEndCh.previousSibling;\n        vEndCh = vChildren[--vEnd];\n      }\n\n      // in case there is no reordering, but just some insertions or removals.\n      if (oldStartCh === oldEndCh || vStart >= vEnd)  break;\n\n      // Reorder corner case 1.\n      if (isSameNode(oldStartCh, vEndCh)) {\n        patchElement(oldStartCh, vEndCh);\n        elemToMove = oldStartCh;\n        oldStartCh = oldStartCh.nextSibling;\n        // place it right behind oldEndCh.\n        insertBefore(element, elemToMove, oldEndCh.nextSibling);\n\n        vEndCh = vChildren[--vEnd];\n      }\n\n      // Reorder corner case 2.\n      else if (isSameNode(oldEndCh, vStartCh)) {\n        patchElement(oldEndCh, vStartCh);\n        elemToMove = oldEndCh;\n        oldEndCh = oldEndCh.previousSibling;\n        // place it right in front of oldStartCh.\n        insertBefore(element, elemToMove, oldStartCh);\n\n        vStartCh = vChildren[++vStart];\n      }\n\n      // insert or move.\n      else {\n        // try to find element in old list.\n        if (keyedChildren == null) {\n          keyedChildren = createKeyMap(oldChildren, oldStartCh, oldEndCh);\n        }\n        \n        elemToMove = keyedChildren[vStartCh.key];\n\n        // create a new element\n        if (elemToMove == null) {\n          elemToMove = create(vStartCh);\n          // place it right in front of oldStartCh\n          insertBefore(element, elemToMove, oldStartCh);\n        }\n        // the element is in the map.\n        else {\n          elemToMove = oldChildren[idxInOld];\n          patchElement(elemToMove, startChild);\n          keyedChildren[elemToMove.key] = void 0;\n          // place it right in front of oldStartCh\n          insertBefore(element, elemToMove, oldStartCh);\n        }\n        vStartCh = vChildren[++vStart];\n      }\n    }\n\n    // if oldStartCh is ahead of oldEndCh or is oldEndCh\n    if (vStart <= vEnd || oldStartCh !== oldEndCh || oldStartCh === oldEndCh) {\n      if (oldStartCh) {\n\n        // oldStartCh is ahead of oldEndCh, which means\n        // there are children to be removed.\n        while(oldStartCh !== oldEndCh) {\n          elemToMove = oldStartCh;\n          oldStartCh = oldStartCh.nextSibling;\n          remove(element, elemToMove);\n        }\n\n        if (isSameNode(oldEndCh, vChildren[vEnd])) {\n          patchElement(oldEndCh, vChildren[vEnd]);\n          if (vStart === vEnd) {\n            return;\n          }\n          vEnd--;\n        }\n\n        else {\n          elemToMove = oldEndCh;\n          oldEndCh = oldEndCh.nextSibling;\n          remove(element, elemToMove);\n        }\n\n        // append new children if there's any.\n        for (let i = vStart; i <= vEnd; i++) {\n          insertBefore(element, create(vChildren[i]), oldEndCh);\n        }\n      }\n    }\n  }\n\n  // case 2: remove all DOM children.\n  else if (oldLen !== 0) {\n    emptyChildren(element);\n  }\n\n  // case 3: insert new DOM children.\n  else if (vLen !== 0) {\n    let newCh;\n\n    for (let i = 0, newCh = vChildren[0]; i < vLen; i++) {\n      element.appendChild(create(newCh));\n    }\n  }\n}\n\n/**\n * Create a map of keyed children.\n * @param {NodeList} children\n * @param {Node} start the node to start from.\n * @param {Node} end  the node to end with\n * @returns { {key: Node} } a map with key equals key, value equals a node associated with this key.\n */\nfunction createKeyMap(children, start, end) {\n  const keyedChildren = {};\n\n  if (start === end && start.key) {\n    keyedChildren[String(start.key)] = start;\n  }\n\n  while(start !== end) {\n    if (start.key != null) {\n      keyedChildren[String(start.key)] = start;\n    }\n    start = start.nextSibling;\n  }\n\n  if (start === end && start.key) {\n    keyedChildren[String(start.key)] = start;\n  }\n\n  return keyedChildren;\n}","import h from './h';\nimport patch from './patch';\nimport VNode from './vnode';\nimport { create as createElement } from './domManager';\n\nconst amberdom = {\n  h,\n  patch,\n  VNode,\n  createElement\n};\n\nexport default amberdom;\n\nexport { default as h } from './h';\nexport { default as patch } from './patch';\nexport { default as VNode } from './vnode';\nexport { create as createElement } from './domManager';"],"names":["isArray","obj","Object","prototype","toString","call","eventHookRe","svgRe","xlinkRe","SVG_NS","XLINK_NS","VNode","tagName","props","children","toUpperCase","key","ns","namespace","test","addNS","vnode","i","len","length","child","this","ch","hooks","name","classIdSpliter","stack","h","selector","Array","slice","arguments","tagInfo","push","pop","String","join","className","result","split","forEach","part","substr","id","parseSelector","Error","insertBefore","parentNode","node","domNode","remove","removeChild","create","document","createTextNode","element","createElementNS","createElement","$props","propName","event","match","handler","warn","message","_listeners","addEventListener","childElement","appendChild","created","setAttribute","attrName","value","isNameSpaced","oldValue","$style","style","cssText","toLocaleLowerCase","e","removeAttribute","setAttributeNS","removeAttributeNS","emptyChildren","childNodes","fc","firstChild","lc","lastChild","patch","domRoot","vRoot","Element","Text","patchElement","nodeType","isSameNode","attrs","old","isSvg","keys","a","attributes","oldChildren","vChildren","oldLen","vLen","elemToMove","keyedChildren","vStart","vEnd","oldStartCh","oldEndCh","vStartCh","vEndCh","nextSibling","previousSibling","createKeyMap","idxInOld","startChild","newCh","replaceChild","textContent","nodeValue","start","end","amberdom"],"mappings":"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"}