{"version":3,"file":"amber-dom.min.js","sources":["../src/util.js","../src/vnode.js","../src/h.js","../src/domManager.js","../src/patch.js","../src/amber-dom.js"],"sourcesContent":["export function isArray (obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\nexport function isEmpty(obj) {\n  return Object.keys(obj|| {}).length === 0;\n}\n\nexport const eventHookRe = /^ev\\-([a-z]+)/;\nexport const svgRe = /(svg|SVG)/;\nexport const xlinkRe = /^xlink:(.*)$/;\nexport const SVG_NS = 'http://www.w3.org/2000/svg';\nexport const XLINK_NS = 'http://www.w3.org/1999/xlink';\n","import { eventHookRe, svgRe, SVG_NS } from './util';\nexport default VNode;\n\n/**\n * Add namespace for `vnode` and recursively add it to its children.\n * @param {VNode} vnode A vnode.\n * @param {String} ns A namespace.\n */\nfunction addNS(vnode, ns) {\n  const children = vnode.children;\n  vnode.ns = ns;\n  vnode.tagName = vnode.tagName ? vnode.tagName.toLocaleLowerCase() : void 0;\n\n  for (let i = 0, len = children.length; i < len; i++) {\n    let child = children[i];\n\n    if (child instanceof VNode) {\n      addNS(child, ns);\n    }\n  }\n}\n\n/**\n * Ensure all children have keys. If no key is provided,\n * use index instead.\n * @param {Array} children \n */\nfunction addChildKeys(children) {\n  let ch;\n\n  for (let i = 0, len = children.length; i < len; i++) {\n    ch = children[i];\n\n    if (ch instanceof VNode) {\n      ch.key = ch.props.key = ch.props.key != null\n        ? ch.props.key : i;\n    }\n  }\n}\n\nclass VNode {\n  /**\n   * @param {String} tagName a tag name. Must be specified.\n   * @param {Object|null} props can be an empty object.\n   * @param {Array|null} children can be an empty array.\n   */\n  constructor(tagName, props, children) {\n    this.tagName = tagName.toUpperCase();\n    this.props = props || {};\n    this.children = children || [];\n    this.key = props && props.key;\n    \n    let ns = (props && props.namespace) ||\n      (svgRe.test(tagName) ? SVG_NS : void 0);\n\n    if (ns) {\n      addNS(this, ns);\n    }\n\n    addChildKeys(this.children);\n\n    // deal with hooks.\n    if (props.hooks) {\n      for (const name in props.hooks) {\n        this[name] = props.hooks[name];\n      }\n      delete props.hooks;\n    }\n  }\n}","import VNode from './vnode';\nimport { isArray } from './util';\nexport default h;\n\n\nconst classIdSpliter = /([\\.#]?[^\\s#.]+)/;\nconst spaceStriper = /^\\s*|\\s*$/;\nconst propSpliter = /\\s*=\\s*/;\nconst stack = [];   // internal stack for parsing children.\n\n/**\n * A selector might contain a tag name followed by some CSS selector.\n * This function was stripped and modiffied from hyperscript's  parseClass.\n * @see https://github.com/hyperhype/hyperscript/blob/master/index.js\n * @param {String} selector \n */\nfunction parseSelector(selector) {\n  const parts = selector.split(classIdSpliter);\n  const result = {};\n\n  parts.forEach(part => {\n    if (part === '')  return;\n\n    if (!result.tagName) {\n      result.tagName = part;\n    } else if (part[0] === '.') {\n      (result.className || (result.className = [])).push(part.substr(1));\n    } else if (part[0] === '#') {\n      result.id = part.substr(1);\n    }\n  });\n\n  result.className && (result.className = result.className.join(' '));\n  return result;\n}\n\n/**\n * Original propto: h(selector, props, ...children).\n * \n * Found a more elegant way to handle children. Referred to Hyperapp's `h` function, which is dead simple. \n * @see https://github.com/hyperapp/hyperapp/blob/master/src/index.js\n * @param {String|Function} selector a built-in tag name or custom function that returns an object created by h.\n * @param {Object} props optional. any style, event listeners, and className should be put here.\n * @param {*} rest optional children. Can be nested.\n */\nfunction h(selector, props) {\n  // Case 1: `selector` is a function.\n  if (typeof selector === 'function') {\n    // use `new` in case it is a class.\n    return new selector(...Array.prototype.slice.call(arguments, 1));\n  }\n\n  let tagInfo, children = [], child, lastPrimitive = false;\n\n  (props || (props = {}))\n\n  // collect children\n  for (let i = arguments.length; i-- > 2; ) {\n    stack.push(arguments[i]);\n  }\n\n  // if props is any of these below, it must be a child.\n  if ((props instanceof VNode) ||\n    (typeof props === 'string') ||\n    (typeof props === 'number') ||\n    (typeof props === 'boolean') ||\n    (isArray(props))\n  ) {\n    stack.push(props);\n    props = {};\n  }\n\n  // handle nested children if there's any.\n  while (stack.length) {\n    if ((child = stack.pop()) && child.pop !== void 0) {\n      for (let i = child.length; i--;)  stack.push(child[i]);\n    }\n\n    else {\n      child = child == null ? '' : child;\n      child = typeof child === 'boolean' ? '' : child;\n      child = typeof child === 'number' ? String(child) : child;\n\n      if (lastPrimitive && typeof child === 'string') {\n        children[children.length - 1] += child;\n      }\n\n      else {\n        children.push(child);\n        lastPrimitive = typeof child === 'string' ? true : false;\n      }\n    }\n  }\n\n  // Case 2: `selector` is 'text'. \n  if (selector === 'text') {\n    return children.length === 0\n      ? ''\n      : children.join('');\n  }\n\n  // Case 3: `selector` is a selector.\n  else if (typeof selector === 'string') {\n    if (props.className && isArray(props.className)) {\n      props.className = props.className.join(' ');\n    }\n\n    tagInfo = parseSelector(selector);\n    if (tagInfo.className) {\n      props.className = props.className\n        ? props.className + ' ' + tagInfo.className\n        : tagInfo.className;\n    }\n\n    if (tagInfo.id) {\n      props.id = props.id ? props.id : tagInfo.id;\n    }\n\n    return new VNode(tagInfo.tagName, props, children);\n  }\n  \n  else {\n    throw new Error(`Unrecognized selector: ${selector}.`)\n  }\n}","import { eventHookRe, XLINK_NS, xlinkRe } from \"./util\";\nimport VNode from './vnode';\n\nexport default domManager;\n\n// dom mangager. Used internally.\nconst domManager = {\n  append,\n  insertBefore,\n  remove,\n  replace,\n  create,\n  setAttribute,\n  emptyChildren\n};\n\n/**\n * @param {Element} parentNode \n * @param {Element} node \n */\nexport function append(parentNode, node) {\n  parentNode.appendChild(node);\n}\n\n/**\n * @param {Element} parentNode\n * @param {Element} node \n * @param {Element} domNode the reference node.\n */\nexport function insertBefore(parentNode, node, domNode) {\n  parentNode.insertBefore(node, domNode);\n}\n\n/**\n * @param {Element} parentNode \n * @param {Element} domNode \n * @param {Element} node \n */\nexport function replace(parentNode, node, domNode) {\n  if (parentNode && node.parentNode === parentNode)\n    parentNode.replaceChild(node, domNode);\n  return domNode;\n}\n\n/**\n * Remove a child on a node if it exists.\n * @param {Element} parentNode \n * @param {Element} node \n */\nexport function remove(parentNode, node) {\n  if (node.parentNode === parentNode) {\n    // Clean up event listeners.\n    const _listeners = node._listeners;\n    if (_listeners) {\n      for (const name in _listeners) {\n        node.removeEventListener(name, _listeners[name]);\n      }\n    }\n    parentNode.removeChild(node);\n  }\n  return node;\n}\n\n/**\n * Create a DOM node represented by `vnode`\n * @param {String|Number|VNode} vnode \n */\nexport function create(vnode) {\n  // create a text node if it is a string or a number.\n  if (typeof vnode === 'string' || typeof vnode === 'number')\n    return document.createTextNode(vnode);\n\n  const tagName = vnode.tagName;\n  const props = vnode.props;\n  const children = vnode.children;\n  const ns = vnode.ns;\n  const element = ns\n    ? document.createElementNS(ns, tagName)\n    : document.createElement(tagName);\n\n  // for next diff.\n  element.$props = props;\n  for (const propName in props) {\n    const event = propName.match(eventHookRe);\n    if (event) {\n      const handler = typeof props[propName] === 'function'\n        ? props[propName]\n        : new Error(`Handler to ${event[1]} is not a function`);\n\n      if (handler instanceof Error) {\n        console.warn(`Failed to add listener for ${event[1]}: ${handler.message}`);\n      }\n\n      // for next diff.\n      (element._listeners || (element._listeners = {}))[event[1]] = handler;\n      element.addEventListener(event[1], handler, false);\n    }\n\n    else {\n      setAttribute(element, propName, props[propName], !!ns);\n    }\n  }\n\n  children.forEach((child, i) => {\n    let childElement;\n\n    if (child instanceof VNode || typeof child === 'string') {\n      childElement = create(child);\n    }\n\n    // TODO: add thunk.\n\n    else {\n      console.warn(`Unrecognizable node: ${child}`);\n    }\n\n    element.appendChild(childElement);\n  });\n\n  if (vnode.created) {\n    vnode.created(element);\n  }\n\n  return element;\n}\n\n/**\n * Set attribute/property on an element.\n * @param {Element} element \n * @param {String} attrName \n * @param {String} value \n */\nexport function setAttribute(element, attrName, value, isNameSpaced) {\n  let ns, oldValue;\n\n  attrName = attrName === 'className' ? 'class' : attrName;\n\n  switch(attrName) {\n  case 'key':\n    element.key = value;\n    break;\n  \n  case 'style':   /** if style is an object, it'll always be patched. */\n    oldValue = element.$style;\n\n    if (!value || typeof value === 'string' || typeof oldValue === 'string') {\n      // if `value` is an object, it will be reset below.\n      element.style.cssText = value || '';\n    }\n    \n    if (value && typeof value === 'object') {\n      // set every old style field to empty.\n      if (typeof oldValue !== 'string') {\n        for (let i in oldValue) {\n          if (!(i in value))\n            element.style[i] = '';\n        }\n      }\n      \n      // you might be wondering why don't I compare the value before setting\n      // it. In fact, no comparison is needed because it won't cause the browser's\n      // repaint or reflow if the new value is the same as old one.\n      for (let i in value) {\n        element.style[i] = value[i];\n      }\n    }\n\n    // for next diff.\n    element.$style = value ? value : '';\n\n    break;\n  \n  case 'class':\n    element.className = value || '';\n    break;\n\n  case 'children':\n    console.warn(`Failed to set \"children\" on element ${element.tagName}.`);\n    break;\n\n  case 'innerHTML':\n    console.warn(`Failed to set \"innerHTML\" on a \"${element.tagName.toLocaleLowerCase()}\".`);\n    break;\n\n  default:\n    if (!isNameSpaced && (attrName in element) && (attrName !== 'type')) {\n      // set it as a property.\n      try {\n        element[attrName] = value ? value : '';\n      } catch(e) {\n        console.warn(`Failed to set attribute: ${attrName} on element \"${element.id ? element.tagName + element.id : element.tagName }\"`)\n      }\n\n      if (value == null) {\n        element.removeAttribute(attrName);\n      }\n    }\n\n    else {\n      ns = isNameSpaced && !!(attrName.match(xlinkRe));\n      // set it as an attribute.\n      if (value && ns) {\n        element.setAttributeNS(XLINK_NS, attrName, value);\n      } else if (!value && ns) {\n        element.removeAttributeNS(XLINK_NS, attrName);\n      } else if (value) {\n        element.setAttribute(attrName, value);\n      } else {\n        element.removeAttribute(attrName);\n      }\n    }\n  }\n}\n\n/**\n * Empty an element's children.\n * Removing from the last child might cause less repaint and reflow.\n * @param {Element} element \n */\nexport function emptyChildren(element) {\n  if (element && element.childNodes && element.childNodes.length) {\n    let fc = element.firstChild, lc = element.lastChild;\n\n    while(fc !== lc) {\n      remove(element, lc);\n      lc = element.lastChild;\n    }\n    remove(element, fc);\n  }\n}","import VNode from './vnode';\nimport { eventHookRe, isEmpty } from './util';\nimport { \n  setAttribute,\n  insertBefore,\n  replace,\n  create,\n  remove,\n  append,\n  emptyChildren } from \"./domManager\";\n\nexport default patch;\n\n\n/**\n * @param {Element|Text} domRoot \n * @param {VNode} vRoot \n */\nfunction patch(domRoot, vRoot) {\n  if (domRoot instanceof Element || domRoot instanceof Text) {\n    domRoot = patchElement(domRoot, vRoot);\n  }\n  return domRoot;\n}\n\n\n/**\n * Patch a DOM node with a vnode.\n * @param {Element|Text} element \n * @param {VNode} vnode \n * @param {Boolean} same If 2 nodes are already checked by `isSameNode`, it should be set true.\n */\nfunction patchElement(element, vnode, same) {\n  if (vnode == null || typeof vnode === 'boolean')\n    vnode = '';\n\n  // 1. both text nodes.\n  if (\n    (element.nodeType === 3) &&\n    (typeof vnode === 'string' || typeof vnode === 'number')\n  ) {\n    const oldText = element.textContent || element.nodeValue;\n    if (oldText !== vnode)\n      element.textContent = vnode;\n  }\n  \n  // 2. are the same node.\n  else if (same || isSameNode(element, vnode)) {\n    patchProps(element, vnode);\n    patchChildren(element, vnode);\n  }\n\n\n  // 3. not the same node.\n  else {\n    let node = create(vnode);\n    replace(element.parentNode, node, element);\n  }\n\n  return element;\n}\n\n/**\n * See if 2 nodes are of the same type & have the same key.\n * Text nodes will do find because it will be patched by `patchedElement` eventually.\n * @param {Element|Text} element \n * @param {VNode} vnode \n */\nfunction isSameNode(element, vnode) {\n  return element.key === vnode.key && element.tagName === vnode.tagName;\n}\n\n/**\n * Patch 2 nodes' props/attributes.\n * @param {Element} element \n * @param {VNode} vnode \n */\nfunction patchProps(element, vnode) {\n  const attrs = vnode.props;\n  let old = element.$props;\n  const isSvg = !!element.ns;\n\n  // if this dom node wasn't diffed before, or wasn't created\n  // by `create`, pull out its attributes and patch them.\n  if (old == null || isEmpty(old)) {\n    old = element.$props = old == null ? {}: old;\n    for (let a = element.attributes, i = a.length; i--; ) {\n      old[a[i].name] = a[i].value;\n    }\n  }\n\n  // remove attributes not on vnode.\n  for(const name in old) {\n    if (old[name] && !(attrs && attrs[name])) {\n      setAttribute(element, name, (old[name] = void 0), isSvg);\n    }\n  }\n\n  // add new & update attributes.\n  // Don't worry about style object,\n  // because `setAttribute` will deal with it.\n  for (const name in attrs) {\n    if (!(name in old) || attrs[name] !== (\n      name === 'value' || name === 'checked' ? element[name] : old[name])\n    ) {\n      setAttribute(element, name, attrs[name], isSvg);\n    }\n  }\n}\n\n/**\n * Patch an element's children\n * @param {Element} element \n * @param {VNode} vnode \n */\nfunction patchChildren(element, vnode) {\n  const oldChildren = element.childNodes,\n        vChildren = vnode.children,\n        oldLen = oldChildren.length,\n        vLen = vChildren.length;\n  \n  // nothing to patch.\n  if (vLen === 0 && oldLen === 0) {\n    return;\n  }\n\n  // Special case: if vnode contains only 1 child.\n  else if (vLen === 1) {\n    let ch = vChildren[0],\n        elemToMove;\n\n    if (oldLen === 1 && isSameNode(oldChildren[0], ch)) {\n      patchElement(oldChildren[0], ch, true);\n    }\n\n    else {\n      // Try to find a child node that match.\n      for (let i = 1; i < oldLen; i++) {\n        if (isSameNode(oldChildren[i], ch)) {\n          patchElement(oldChildren[i], ch, true);\n\n          elemToMove = oldChildren[i];\n          break;\n        }\n      }\n\n      // If it wasn't found, create one from the vnode.\n      if (elemToMove === void 0) {\n        elemToMove = create(ch);\n      }\n      emptyChildren(element);\n      element.appendChild(elemToMove);\n    }\n  }\n\n  // case 1: both have children.\n  else if (oldLen !== 0 && vLen > 1) {\n    let keyedChildren,\n        vStart = 0,\n        vEnd = vLen - 1,\n\n        oldStartCh = element.firstChild,\n        oldEndCh = element.lastChild,\n\n        vStartCh = vChildren[vStart],\n        vEndCh = vChildren[vEnd],\n\n        elemToMove;\n\n    while(vStart <= vEnd && oldStartCh !== oldEndCh) {\n      while(vStart <= vEnd && oldStartCh !== oldEndCh && \n        oldStartCh && vStartCh && isSameNode(oldStartCh, vStartCh)\n      ) {\n        patchElement(oldStartCh, vStartCh, true);\n\n        oldStartCh = oldStartCh.nextSibling;\n        vStartCh = vChildren[++vStart];\n      }\n\n      while(vStart <= vEnd && oldStartCh !== oldEndCh && \n        oldEndCh && vEndCh && isSameNode(oldEndCh, vEndCh)\n      ) {\n        patchElement(oldEndCh, vEndCh, true);\n\n        oldEndCh = oldEndCh.previousSibling;\n        vEndCh = vChildren[--vEnd];\n      }\n\n      // in case there is no reordering, but just some insertions or removals.\n      if (oldStartCh === oldEndCh || vStart >= vEnd)  break;\n\n      // Reorder corner case 1.\n      if (isSameNode(oldStartCh, vEndCh)) {\n        patchElement(oldStartCh, vEndCh, true);\n        elemToMove = oldStartCh;\n        oldStartCh = oldStartCh.nextSibling;\n        // place it right behind oldEndCh.\n        insertBefore(element, elemToMove, oldEndCh.nextSibling);\n\n        vEndCh = vChildren[--vEnd];\n      }\n\n      // Reorder corner case 2.\n      else if (isSameNode(oldEndCh, vStartCh)) {\n        patchElement(oldEndCh, vStartCh, true);\n        elemToMove = oldEndCh;\n        oldEndCh = oldEndCh.previousSibling;\n        // place it right in front of oldStartCh.\n        insertBefore(element, elemToMove, oldStartCh);\n\n        vStartCh = vChildren[++vStart];\n      }\n\n      // insert or reorder.\n      else {\n        // try to find element in old list.\n        if (keyedChildren == null) {\n          keyedChildren = createKeyMap(oldChildren, oldStartCh, oldEndCh);\n        }\n        \n        elemToMove = keyedChildren[vStartCh.key];\n\n        // not found. Create a new child.\n        if (elemToMove == null) {\n          elemToMove = create(vStartCh);\n          // place it right in front of oldStartCh\n          insertBefore(element, elemToMove, oldStartCh);\n        }\n        // found. Move it to its place.\n        else {\n          patchElement(elemToMove, startChild);\n          keyedChildren[elemToMove.key] = void 0;\n          // place it right in front of oldStartCh\n          insertBefore(element, elemToMove, oldStartCh);\n        }\n        vStartCh = vChildren[++vStart];\n      }\n    }\n\n    // NOTE: The outer if might be unnecessary.\n    // if oldStartCh is ahead of oldEndCh or is oldEndCh\n    if (vStart <= vEnd || oldStartCh !== oldEndCh || oldStartCh === oldEndCh) {\n      if (oldStartCh) {\n\n        // oldStartCh is ahead of oldEndCh, which means\n        // there are children to be removed.\n        while(oldStartCh !== oldEndCh) {\n          elemToMove = oldStartCh;\n          oldStartCh = oldStartCh.nextSibling;\n          remove(element, elemToMove);\n        }\n\n        if (isSameNode(oldEndCh, vChildren[vEnd])) {\n          patchElement(oldEndCh, vChildren[vEnd], true);\n          if (vStart === vEnd) {\n            return;\n          }\n          vEnd--;\n        }\n\n        else {\n          elemToMove = oldEndCh;\n          oldEndCh = oldEndCh.nextSibling;\n          remove(element, elemToMove);\n        }\n\n        // append new children if there's any.\n        for (let i = vStart; i <= vEnd; i++) {\n          insertBefore(element, create(vChildren[i]), oldEndCh);\n        }\n      }\n    }\n  }\n\n  // case 2: remove all DOM children.\n  else if (oldLen !== 0) {\n    emptyChildren(element);\n  }\n\n  // case 3: insert new DOM children.\n  else if (vLen !== 0) {\n    let newCh;\n\n    for (let i = 0, newCh = vChildren[0]; i < vLen; i++) {\n      element.appendChild(create(newCh));\n    }\n  }\n}\n\n/**\n * Create a map of keyed children.\n * @param {NodeList} children\n * @param {Node} start the node to start from.\n * @param {Node} end  the node to end with\n * @returns { {key: Node} } a map with key equals key, value equals a node associated with this key.\n */\nfunction createKeyMap(children, start, end) {\n  const keyedChildren = {};\n\n  if (start === end && start.key) {\n    keyedChildren[String(start.key)] = start;\n  }\n\n  while(start !== end) {\n    if (start.key != null) {\n      keyedChildren[String(start.key)] = start;\n    }\n    start = start.nextSibling;\n  }\n\n  if (start === end && start.key) {\n    keyedChildren[String(start.key)] = start;\n  }\n\n  return keyedChildren;\n}","import h from './h';\nimport patch from './patch';\nimport VNode from './vnode';\nimport { create as createElement } from './domManager';\n\nconst amberdom = {\n  h,\n  patch,\n  VNode,\n  createElement\n};\n\nexport default amberdom;\n\nexport { default as h } from './h';\nexport { default as patch } from './patch';\nexport { default as VNode } from './vnode';\nexport { create as createElement } from './domManager';"],"names":["isArray","obj","Object","prototype","toString","call","eventHookRe","svgRe","xlinkRe","SVG_NS","XLINK_NS","VNode","tagName","props","children","toUpperCase","key","ns","namespace","test","addNS","vnode","toLocaleLowerCase","i","len","length","child","this","ch","hooks","name","classIdSpliter","stack","h","selector","Array","slice","arguments","tagInfo","lastPrimitive","push","pop","String","join","className","result","split","forEach","part","substr","id","parseSelector","Error","insertBefore","parentNode","node","domNode","remove","_listeners","removeEventListener","removeChild","create","document","createTextNode","element","createElementNS","createElement","$props","propName","event","match","handler","warn","message","addEventListener","childElement","appendChild","created","setAttribute","attrName","value","isNameSpaced","oldValue","$style","style","cssText","e","removeAttribute","setAttributeNS","removeAttributeNS","emptyChildren","childNodes","fc","firstChild","lc","lastChild","patch","domRoot","vRoot","Element","Text","patchElement","same","nodeType","isSameNode","attrs","old","isSvg","keys","a","attributes","oldChildren","vChildren","oldLen","vLen","elemToMove","keyedChildren","vStart","vEnd","oldStartCh","oldEndCh","vStartCh","vEndCh","nextSibling","previousSibling","createKeyMap","startChild","newCh","replaceChild","textContent","nodeValue","start","end","amberdom"],"mappings":"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"}